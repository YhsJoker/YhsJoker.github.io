---
title: 小楷与小狗
date: 2022-11-17 23:52:22
tags:
	- [bjfuacm]
	- [搜索]
	- [数论]
	- [绿]
categories: 题解
description: 思维题,数据范围看着很大,实际上可以转化为很小的范围
---

## [原题戳这里](https://www.bjfuacm.com/problem/21-acm-new-M)

## 题目描述

小楷和小狗喜欢玩游戏，有一天小超开发出了一个新游戏，小楷和小狗想要尝试。

小超的游戏规则是这样的：给出长度为n的一个序列a，由小楷和小狗从中任意选取几个数，当两人取得的数之和相等时或者不能再取数时游戏结束。

但是小超不喜欢相同的数，他规定每个人取得的数的集合中不能有相同的数出现，并且当一个人取走x后，另一个人也不能再取走x。

现在小超想知道游戏结束时两个人取的数分别是多少。

例如：当小超给出序列为“1、2、1、3、5”时，小楷可以取“1、2”，而小狗可以取“3“。若答案存在则保证一定能取到。现在让你输出游戏结束时每个人各自取得的数，如果两人取得的数之和不相等则输出-1.


## 输入格式

第一行输入一个整数n(1≤n≤100000)

第二行输入n个整数ai(1≤ai≤100000)


## 输出格式

如果不存在答案输出-1
否则先输出第一个人取得的数的数量x，接下来一行输出x个数表示这个人取得的数。

第三行输出第二个人取得的数的数量y，接下来一行输出y个数表示这个人取得的数。(如果有多个答案请输出任意一种)

## 输入输出样例

### 输入 #1
```
5
1 2 1 3 5
```
### 输出 #1
```
2
1 2
1
3
```
### 输入 #2
```
5
1 1 1 1 1
```
### 输出 #2
```
-1
```

---

## 题目大意
在一组集合中,找到任意两组非空真子集,使其和相同,如果没有则输出-1.  
其中,两组非空真子集中不得有相同元素.


## 思路

由于需要不重复的元素,所以可以用set来实现去重功能,然后如果当n的值很小的话,我们可以通过dfs来枚举每一种可能,找出其中一组解.但是此时的n很大,我们可以考虑缩小问题的规模.

我们可以得出结论我们考虑构造一个序列An={1,2,4,...65536},这是在数据范围内无法找到任何一组解的最大集合,仅含有17个元素,所以,当n>17时,一定存在一组解.因此,当n比较大时,我们可以只对其中任意18个元素跑dfs,一定能找出一组解.

## 代码
```cpp
#include<iostream>
#include<set>
#include<map>
#include<vector>
 
using namespace std;
using ll=long long;
 
int n;
set<ll> se;//去重
vector<ll> v;

bool flag=0;    //flag=1就是找到了
 
vector<ll> vv;
map<ll,vector<ll>> mp;  //key:一组集合中元素的和  //value:集合元素

void dfs(int idx,ll sum)
{
	if(flag) return;
	
	if(idx==v.size())
	{
		if(vv.size())
		{
			if(mp.count(sum))       //如果当前集合的元素和与之前其中一组元素和相同,就打印
			{
				cout<<mp[sum].size()<<endl;
				for(auto e:mp[sum])
					cout<<e<<" ";
				cout<<endl;
				cout<<vv.size()<<endl;
				for(auto e:vv)
					cout<<e<<" ";
				cout<<endl;
				flag=1;
			}
			else        //否则将当前集合存入map
			{
				mp[sum]=vv;
			}
		}
		return;
	}
	
	dfs(idx+1,sum);
	
	vv.push_back(v[idx]);
	dfs(idx+1,sum+v[idx]);
	vv.pop_back();
}
 
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin>>n;

	for(int i=0,x;i<n;i++) 
        cin>>x,se.insert(x);

	for(auto e:se)
	{
		v.push_back(e);
		if(v.size()>17) //当存在18个元素时,一定存在一组解,因此就可以跳出循环了
			break;
	}
	
	dfs(0,0);

	if(!flag)
		cout<<-1;
}
```