---
title: 勇者阿狗
date: 2022-11-17 11:43:03
tags:
	- [bjfuacm]
	- [最短路]
	- [紫]
categories: 题解
description: 思维题,如果没见过类似题型很难想到这种建图方式
---

## [原题戳这里](http://www.bjfuacm.com/problem/21-acm-new-L)

## 题目描述
美丽的汪汪世界第k次遭到了邪恶的亮亮大魔王的攻击！！！

现在阿狗必须打败亮亮大魔王拯救世界，他向你请求帮助。

你经过研究发现：要打败魔王必须要收集一定量的勇士能量，而打败第k次魔王入侵需要的勇士能量定义为：k的某个正整数倍的每位数字的和，比如第6次魔王入侵需要的勇士能量是3（答案对应的情况是6的二倍 6×2=12，每位数字和1+2=3）第10次魔王入侵需要的勇士能量是1(对于10，10×1=10，每位数字的和为1), 第41次入侵需要的勇士能量为5 。

现在你要求出需要勇士能量的最小值。

## 输入格式
第一行输入一个t（t<=50），接下来t组数据每组数据读入一个k(1≤k≤100000)表示是第k次魔王入侵。

## 输出格式
输出t行数。每行都包含一个数，代表需要的最小勇士能量值。

## 输入输出样例

### 输入#1
```
2
41
79992
```

### 输出#1
```
5
36
```

---

## 题目大意
定义sum(x)为x的每位数字之和
找到一个正整数n,使得sum(n*k)最小

## 思路

我们可以知道，每一个数字都可以通过1进行有限个×10和+1这两个操作构造出来，比如,31=(1+1+1)*10+1,其中，×10操作不会改变每位数字之和，+1操作会使每位数字之和+1。那么我们就可以通过这种方式来构造出来k的倍数，也就是对k取模为0的数。

那我们就可以从1开始，对1进行+1和×10的操作，直到找到对k取模为0的数。根据同余性质 
1. 若a≡b(mod m)，则a±c≡b±c(mod m)
2. 若a≡b(mod m)，则ac≡bc(mod m)

我们可以知道，对大于等于k的数n进行×10和+1操作和对n%k进行×10和+1操作等同，那么我们可以构造一个图，图中的i节点为对k取模为i的数。也就是说，图中会有k个节点，分别为0，1，2……k-2，k-1。

那我们如何建边呢？先明确一点，这是一个有向图，从u到v边的长度为sum(v)-sum(u)，也就是说，从u点到u+1点的边长为1，因为需要给最后一位数+1，就会导致sum(v)=sum(u)+1；从u点到u×10点的边长为0，因为sum(u)==sum(u×10)。这样，我们将1，2，一直到k-1的所有点建边，然后跑从1到0的最短路即可。从1到0的路径长度含义sum(n×k)-sum(1)，sum(1)==1。为什么，因为假设中途经过了p1,p2,p3……pn个点,那么路径长度为sum(p1)-sum(1) + sum(p2)-sum(p1) + … +sum(n*k)-sum(pn),消掉相同项后得出结论。

思路有了后，代码很简单，就是一个普通的最短路即可。
注意：当k==1时，由于无法建边，所以直接输出1即可

## 代码示例

```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<utility>
using namespace std;
 
const int N=1e5+10,M=2e6+10;
 
int h[N],e[M],ne[M],w[M],idx,dist[N];
bool st[N];
int t,k;
 
void add(int a,int b,int c)
{
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}
 
void dijkstra()
{
	using pii=pair<int,int>;
	priority_queue<pii,vector<pii>,greater<pii>> q;
	dist[1]=1;
	q.push(make_pair(1,1));
	while(q.size())
	{
		int u=q.top().second;
		q.pop();
		if(st[u]) continue;
		st[u]=true;
		for(int i=h[u];i!=-1;i=ne[i])
		{
			int j=e[i];
			if(dist[u]+w[i]<dist[j])
			{
				dist[j]=dist[u]+w[i];
				q.push(make_pair(dist[j],j));
			}
		}
	}
}
 
int main()
{
	cin>>t;
	while(t--)
	{
		memset(dist,0x3f,sizeof dist);
		memset(h,-1,sizeof h);
		memset(st,0,sizeof st);
		idx=0;
		cin>>k;
		if(k==1) dist[0]=1;
		for(int i=1;i<k;i++)
		{
			add(i,(i+1)%k,1);
			add(i,(i*10)%k,0);
		}
		dijkstra();
		cout<<dist[0]<<endl;
	}
}
```