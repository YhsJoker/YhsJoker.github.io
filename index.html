
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Yhs_JokerのBlog</title>
        <meta name="author" content="Yhs_Joker">
        <meta name="description" content="There is only one kind of heroism in the world, which is to love life after knowing the truth of life.">
        <meta name="keywords" content="">
        <link rel="icon" href="/img/images/head_portrait.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.2.0/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Yhs_JokerのBlog</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Yhs_JokerのBlog</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(/img/images/background.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Yhs_JokerのBlog</h1>
                <h3>一个ACMerの题解网站</h3>
                <h5>There is only one kind of heroism in the world, which is to love life after knowing the truth of life.</h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2023/04/15/Codeforces Round 863 (Div.3)/">
        <h2 class="post-title">Codeforces Round 863 (Div.3)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/4/15
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <span id="more"></span>

<h2 id="原题链接：戳这里"><a href="#原题链接：戳这里" class="headerlink" title="原题链接：戳这里"></a>原题链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1811">戳这里</a></h2><p>+++</p>
<h2 id="A-Insert-Digit"><a href="#A-Insert-Digit" class="headerlink" title="A. Insert Digit"></a>A. Insert Digit</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>输入一个数字n和一个数字d(d&lt;&#x3D;9)， 将数字d插入到数字n的任意位置中， 求n的最大值。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当k大于n中的某一个数时， 插入到这个数的前一个位置一定能保证最大</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">int n, k;
char s[N];
 
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;
    for(int i=0; i&lt;n; i++)&#123;
        if(k&gt;s[i]-&#39;0&#39;)&#123;
            for(int j=0; j&lt;i; j++) cout&lt;&lt;s[j];
            cout&lt;&lt;k;
            for(int j=i; j&lt;n; j++) cout&lt;&lt;s[j];
            cout&lt;&lt;&#39;\n&#39;;
            return;
        &#125;
    &#125;cout&lt;&lt;s&lt;&lt;k&lt;&lt;&#39;\n&#39;;
    
    
&#125;
</code></pre>
<h2 id="B-Conveyor-Belts"><a href="#B-Conveyor-Belts" class="headerlink" title="B. Conveyor Belts"></a>B. Conveyor Belts</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将一个点所在的层数理解为到最外层的最短距离， 则本题可以转化为求两个点所在层数的差值</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">int n, x1, y1, x2, y2;
 
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
    int t1 = min(min(x1, y1), min(n+1-x1, n+1-y1));
    int t2 = min(min(x2, y2), min(n+1-x2, n+1-y2));
    cout&lt;&lt;abs(t1-t2)&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>
<h2 id="C-Restore-the-Array"><a href="#C-Restore-the-Array" class="headerlink" title="C. Restore the Array"></a>C. Restore the Array</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>构造一个序列a， 使得其经过转化后等于给定的序列b。</p>
<p>转化规则为b[i] &#x3D; max(a[i], a[i+1])</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先a[1]应该等于b[1]，接下来每次选择a[i+1]值的时候， 先考虑是否a[i]已经等于b[i]， 如果相等的话则只要a[i+1]&lt;&#x3D;a[i]并且a[i+1]&lt;&#x3D;b[i+1]就可以满足要求, 并且如果想要接下来的取值范围更大， 那么我们要让a[i+1]的值尽可能等于b[i+1]。 当a[i]不等于b[i]时， 则a[i]就取值为b[i]即可。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">int n;
int a[N], b[N];
 
void solve()&#123;
    cin&gt;&gt;n;
    for(int i=1; i&lt;n; i++) cin&gt;&gt;b[i];
    a[1] = b[1];
    for(int i=2; i&lt;=n; i++)&#123;
        if(a[i-1]==b[i-1]) &#123;
            if(i!=n&amp;&amp;b[i]&lt;=a[i-1])
                a[i] = b[i];
            else
                a[i] = 0;
        &#125;
        else a[i] = b[i-1];
    &#125;
    for(int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>
<h2 id="D-Umka-and-a-Long-Flight"><a href="#D-Umka-and-a-Long-Flight" class="headerlink" title="D. Umka and a Long Flight"></a>D. Umka and a Long Flight</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个n阶斐波那契矩形， 问是否可以将其用以下规则剪切为n+1个正方形。</p>
<ul>
<li>喷涂的那一块正方形边长为1</li>
<li>最多有一对正方形边长相同</li>
<li>每一块正方形的边长都是斐波那契数</li>
</ul>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>根据斐波那契数的性质， 我们发现每次减出一块正方形时都优先剪出最大的正方形， 即边长为当前矩形的宽。然后每一次都这样减下去， 如果出现无论怎么剪都无法让涂色的块不出现在正方形中的话， 则无法满足题意。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">int f[N] = &#123;1, 1&#125;;
 
void init()&#123;
    for(int i = 2; i&lt;=45; i++) f[i] = f[i-1] + f[i-2];
&#125;
 
int n, x, y;
 
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;
    int h = f[n], w = f[n+1];
    while(!(h==1&amp;&amp;w==1))&#123;
        if(h&lt;w)&#123;
            if(y&gt;h) w-=h, y-=h;
            else if(y&lt;=w-h) w-=h;
            else&#123;
                cout&lt;&lt;&quot;NO\n&quot;;
                return;
            &#125;
        &#125;
        else&#123;
            if(x&gt;w) x-=w, h-=w;
            else if(x&lt;=h-w) h-=w;
            else&#123;
                cout&lt;&lt;&quot;NO\n&quot;;
                return;
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;&quot;YES\n&quot;;
&#125;
</code></pre>
<h2 id="E-Living-Sequence"><a href="#E-Living-Sequence" class="headerlink" title="E. Living Sequence"></a>E. Living Sequence</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数在a序列的位置， 求该数是多少。 其中序列a为正整数序列与包含4的数的序列的差集</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>通过打表找规律即可。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">int a[N] = &#123;1&#125;;
int b[N] = &#123;1&#125;;
int idx;
 
void init()&#123;
    for(int i=1; b[i-1]&lt;=1e12; i++) a[i] = a[i-1]*10, b[i] = b[i-1]*9, idx = i;
&#125;
 
int n;
 
void solve()&#123;
    cin&gt;&gt;n;
    int res = 0;
    for(int i = idx; i&gt;=0; i--)&#123;
        if(b[i]&gt;n) continue;
        int times = n/b[i];
        res+=(n/b[i])*a[i];
        n-=n/b[i]*b[i];	
        if(times&gt;=4) res+=a[i];
    &#125;
    cout&lt;&lt;res&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>
<h2 id="F-Is-It-Flower"><a href="#F-Is-It-Flower" class="headerlink" title="F. Is It Flower?"></a>F. Is It Flower?</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>判定一个图形是否满足以下性质。</p>
<ul>
<li><p>有n个顶点和m条边</p>
</li>
<li><p>由k+1个正k边形组成, 其中中心图形的每一个顶点都有一个k边形。如图所示。</p>
</li>
</ul>
<p>![k-flowers](..\img\Codeforces Round 863 (Div.3)\k-flowers.png)</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>判断这是否满足以下条件：</p>
<ul>
<li>有k*k个顶点，k*(k+1)条边， k&gt;&#x3D;3</li>
<li>满足度数为4的点有k个， 剩余点的度数均为2</li>
<li>度数为4的k个点构成一个环</li>
<li>度数为4的每一点都挂着一个长度为k环</li>
</ul>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">
int n, m, k;
vector&lt;int&gt; g[N];
int deg[N];
bool st[N];
 
void input()&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1; i&lt;=n; i++) &#123;
        g[i].clear();
        deg[i] = 0;
        st[i] = 0;
    &#125;
    for(int i=0; i&lt;m; i++)&#123;
        int x, y;
        cin&gt;&gt;x&gt;&gt;y;
        g[x].push_back(y);
        g[y].push_back(x);
        deg[x]++, deg[y]++;
    &#125;
&#125;
 
bool check_deg()&#123;
    int deg_2_num = 0, deg_4_num = 0;
    for(int i=1; i&lt;=n; i++)&#123;
        if(deg[i] == 2) deg_2_num++;
        if(deg[i] == 4) deg_4_num++;
    &#125;
    return deg_4_num == k &amp;&amp; deg_2_num + deg_4_num == n;
&#125;
 
int starting_ver;
 
bool check_deg_4_is_circle_dfs(int u, int fa, int num)&#123;
    vector&lt;int&gt; deg_4_vers;
    
    bool has_starting_ver = 0;
    
    for(auto ver:g[u])&#123;
        if(ver == starting_ver) has_starting_ver = 1;
        if(deg[ver] == 4 &amp;&amp; !st[ver])&#123;
            deg_4_vers.push_back(ver);
        &#125;
    &#125;
    
    st[u] = 1;
    num++;
    
    int vers_size = deg_4_vers.size();
    
    if(vers_size == 0)&#123;
        return num == k &amp;&amp; has_starting_ver;
    &#125;
    else if(vers_size == 2)&#123;
        if(fa == 0) deg_4_vers.pop_back();
        else return false;
    &#125;
    else if(vers_size &gt; 2 )&#123;
        return false;
    &#125;
    
    return check_deg_4_is_circle_dfs(deg_4_vers[0], u, num);
&#125;
 
bool check_deg_2_is_circle_dfs(int u, int fa, int num)&#123;
    vector&lt;int&gt; deg_2_vers;
    
    bool has_starting_ver = 0;
    
    for(auto ver:g[u])&#123;
        if(ver == starting_ver) has_starting_ver = 1;
        if(deg[ver] == 2 &amp;&amp; !st[ver])&#123;
            deg_2_vers.push_back(ver);
        &#125;
    &#125;
    
    st[u] = 1;
    num++;
    
    int vers_size = deg_2_vers.size();
    
    if(vers_size == 0)&#123;
        return num == k &amp;&amp; has_starting_ver;
    &#125;
    else if(vers_size == 2)&#123;
        if(fa == 0) deg_2_vers.pop_back();
        else return false;
    &#125;
    else if(vers_size &gt; 2 )&#123;
        return false;
    &#125;
    
    return check_deg_2_is_circle_dfs(deg_2_vers[0], u, num);
&#125;
 
bool check_deg_4_is_circle()&#123;
    for(int i=1; i&lt;=n; i++)&#123;
        if(deg[i] == 4)&#123;
            starting_ver = i;
            return check_deg_4_is_circle_dfs(i, 0, 0);
        &#125;
    &#125;
    return false;
&#125;
 
bool check_all_deg_2_is_circle()&#123;
    for(int i=1; i&lt;=n; i++)&#123;
        if(deg[i] == 4)&#123;
            starting_ver = i;
            if(!check_deg_2_is_circle_dfs(i, 0, 0))
                return false;
        &#125;
    &#125;
    return true;
&#125;
 
bool check()&#123;
    if(!check_deg()) return false;
    if(!check_deg_4_is_circle()) return false;
    if(!check_all_deg_2_is_circle()) return false;
    return true;
&#125;
 
void solve()
&#123;
    input();
    
    k = round(sqrt(n));
    if(k&lt;3 || k*k!=n || k*(k+1)!=m)&#123;
        cout&lt;&lt;&quot;NO\n&quot;; return;
    &#125;
    
    if(check())&#123;
        cout&lt;&lt;&quot;YES\n&quot;;
    &#125;
    else&#123;
        cout&lt;&lt;&quot;NO\n&quot;;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Codeforces/" style="color: #03a9f4">
                Codeforces
            </a>
        </span>
        
    </div>
    <a href="/2023/04/15/Codeforces Round 863 (Div.3)/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/01/17/2023年BJFU寒假算法训练营DAY3/">
        <h2 class="post-title">2023年BJFU寒假算法训练营DAY3</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/题解/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/1/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <span id="more"></span>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4913">https://www.luogu.com.cn/problem/P4913</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>求二叉树的深度</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本代码采用朴素建树方式，即每一个节点存储其左右儿子节点下标<br>dfs：求出两个子树的深度，那么该树的深度就是最大子树深度+1<br>bfs：记录父节点深度，下一层深度为当前节点深度+1，到叶子节点时更新最大深度</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;
using pii=pair&lt;int,int&gt;;

const int N = 1e6+10;

struct node
&#123;
    int ord, l, r;  //ord： 节点编号  l：左儿子下标  r：右儿子下标
&#125;;

int n;
node tr[N]; //建树

void init()
&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)
    &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        tr[i] = &#123;i, l, r&#125;;
    &#125;
&#125;

int dfs(int u)
&#123;
    if(tr[u].ord == 0)  //空节点没有深度
        return 0;
    return max(dfs(tr[u].l), dfs(tr[u].r)) + 1;
&#125;

int bfs(int u)
&#123;
    int max_depth = 0;
    
    queue&lt;pii&gt; q;
    q.push(&#123;u, 1&#125;);
    while(!q.empty())
    &#123;
        pii t = q.front();
        q.pop();
        
        int ord = t.first, depth = t.second;
        
        if(tr[ord].l==0 &amp;&amp; tr[ord].r==0) &#123;max_depth = max(max_depth, depth); continue;&#125;
        if(tr[ord].l) q.push(&#123;tr[ord].l, depth + 1&#125;);
        if(tr[ord].r) q.push(&#123;tr[ord].r, depth + 1&#125;);
    &#125;
    
    return max_depth;
&#125;

int main()
&#123;
    init();
    //cout &lt;&lt; dfs(1);
    cout &lt;&lt; bfs(1);
&#125;
</code></pre>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1364">https://www.luogu.com.cn/problem/P1364</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>选择一个点，使这个点到其他所有点的距离乘权重之和最小</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题采用邻接表建树<br>由于数据范围很小，因此我们可以枚举每一个点，求出以该点为医院的距离和，更新最小距离和。dfs方式为返回该节点及其子树的距离和。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include&lt;cstring&gt;

using namespace std;

const int N = 110, M =210; 

int h[N], w[N], e[M], ne[M], idx;

void add(int u, int v)
&#123;
    e[idx] = v;
    ne[idx] = h[u];
    h[u] = idx++;
&#125;

int dfs(int u, int fa, int dist)
&#123;
    int tot_dist = w[u] * dist;
    for(int i = h[u]; ~i; i = ne[i])
    &#123;
        int j = e[i];
        if(j != fa) tot_dist += dfs(j, u, dist + 1);
    &#125;
    return tot_dist;
&#125;

int n;

void init()
&#123;
    memset(h, -1, sizeof h);
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)
    &#123;
        int u, v;
        cin &gt;&gt; w[i] &gt;&gt; u &gt;&gt; v;
        if(u) add(i, u), add(u, i);
        if(v) add(i, v), add(v, i);
    &#125;
&#125;

int main()
&#123;
    init();
    int res = 0x3f3f3f3f;
    for(int i = 1; i &lt;= n; i++)
        res = min(res, dfs(i, 0, 0));
    cout &lt;&lt; res;
&#125;
</code></pre>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2853">https://www.luogu.com.cn/problem/P2853</a></p>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>求所有牛可以到达的点的个数</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对每头牛能走到的地方记录，如果某一点被记录了n次（n为牛的个数），那么这个点就是一个所有牛可以走到的点。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include&lt;cstring&gt;

using namespace std;

const int K = 105, N = 1005, M = 10005;

int a[K];
int h[N], e[M], ne[M], idx;
bool st[N];     //记录某一头牛能走到的点
int num[N];     //记录该点能被几头牛走到

int k,n,m;

void add(int a, int b)
&#123;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
&#125;

void init()
&#123;
    memset(h, -1, sizeof h);
    cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; k; i++)
        cin &gt;&gt; a[i];
    for(int i = 0; i &lt; m; i++)
    &#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
    &#125;
&#125;

void dfs(int u, int fa)
&#123;
    if(st[u]) return;   //如果已经走过该点，就不需要再走一遍了
    st[u] = 1;
    num[u]++;
    for(int i = h[u]; ~i; i=ne[i])
    &#123;
        int j = e[i];
        dfs(j, u);
    &#125;
&#125;

int main()
&#123;
    init();
    
    for(int i = 0; i &lt; k; i++)
    &#123;
        memset(st, 0, sizeof st);
        dfs(a[i], 0);
    &#125;
    
    int res = 0;
    
    for(int i = 1; i &lt;= n; i++)
        if(num[i] == k)
            res++;
    
    cout&lt;&lt;res;
&#125;
</code></pre>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8604">https://www.luogu.com.cn/problem/P8604</a></p>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定起点和终点，若失去某一点后无法从起点走到终点，那么称这一点为危险点。求危险点的个数。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>如果某一个点为危险点，那么从起点走到终点的过程中一定会经过。因此可以dfs遍历所有从起点到终点的路径，若某一点被经过的次数等于路径条数，那么该点就是危险点。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 1005, M = 2005;

int h[N], e[M * 2], ne[M * 2], idx;
int num[N]; //某点被经过的次数
bool st[N]; //某点是否被经过

int n, m;
int tot, orig, dest;

void add(int u, int v)
&#123;
    e[idx] = v;
    ne[idx] = h[u];
    h[u] = idx++;
&#125;

void dfs(int u)
&#123;
    if(st[u]) return;
    if(u == dest)   //到达终点
    &#123;
        tot++;  //路径条数变化
        for(int i=1; i &lt;= n; i++)   //将该路径下经过的点记入次数
            num[i] += st[i];
        return;
    &#125;
    st[u] = 1;  //在该路径下不能重复经过某一点
    for(int i = h[u]; ~i; i=ne[i])
    &#123;
        int j = e[i];
        dfs(j);
    &#125;
    st[u] = 0;  //走过该点后，就可以再次走该点
&#125;

void init()
&#123;
    memset(h, -1, sizeof h);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; m; i++)
    &#123;
        int u, v;
        cin &gt;&gt; u &gt;&gt;v;
        add(u, v);
        add(v, u);
    &#125;
    cin &gt;&gt; orig &gt;&gt; dest;
&#125;

int main()
&#123;
    init();
    dfs(orig);
    
    int res = 0;
    for(int i = 1; i &lt;= n; i++)
        if(num[i] == tot)
            res++;

    cout &lt;&lt; res - 1;
&#125;
</code></pre>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1443">https://www.luogu.com.cn/problem/P1443</a></p>
<h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>求马走到每一个点最少需要几步</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>bfs模板题，注意不要越界</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;

using namespace std;
using pii = pair&lt;int, int&gt;;

const int N = 405;

int n, m, x, y;
int dist[N][N];

int move_x[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;, move_y[8] = &#123;-1, -2, -2, -1, 1, 2, 2, 1&#125;;

void bfs()
&#123;
    queue&lt;pii&gt; q;
    dist[x][y] = 0;
    q.push(&#123;x, y&#125;);
    while(!q.empty())
    &#123;
        pii t = q.front();
        q.pop();
        int x = t.first, y = t.second;
        for(int i = 0; i &lt; 8; i++)
        &#123;
            int xx = x + move_x[i], yy = y + move_y[i];
            if(xx &lt; 1 || xx &gt; n) continue;
            if(yy &lt; 1 || yy &gt; m) continue;
            if(dist[xx][yy] != -1) continue;
            dist[xx][yy] = dist[x][y] + 1;
            q.push(&#123;xx, yy&#125;);
        &#125;
    &#125;
&#125;

void init()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++)
            dist[i][j] = -1;
&#125;

int main()
&#123;
    init();
    bfs();
    for(int i = 1; i &lt;= n; i++)
    &#123;
        for(int j = 1; j &lt;= m; j++)
        &#123;
            printf(&quot;%-5d&quot;, dist[i][j]);     //除非你很清楚你在做什么，否则不要将cin/cout和scanf/printf混用
        &#125;
        printf(&quot;\n&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1162">https://www.luogu.com.cn/problem/P1162</a></p>
<h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>将封闭图形内部的0变为2</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>先将外围的0变为别的数，再将剩余的0变为2。可以选择任意搜索方式</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;
using pii = pair&lt;int, int&gt;;

const int N = 40;

int n;
int a[N][N];

int move_x[4] = &#123;1, 0, -1, 0&#125;, move_y[4] = &#123;0, -1, 0, 1&#125;;

void bfs(int x, int y, int color)
&#123;
    queue&lt;pii&gt; q;
    a[x][y] = color;
    q.push(&#123;x,y&#125;);
    while(!q.empty())
    &#123;
        pii t = q.front();
        q.pop();
        int x = t.first, y = t.second;
        for(int i = 0; i &lt; 4; i++)
        &#123;
            int xx = x + move_x[i], yy = y + move_y[i];
            if(xx &lt; 0 || xx &gt; n+1) continue;
            if(yy &lt; 0 || yy &gt; n+1) continue;
            if(a[xx][yy] != 0) continue;
            a[xx][yy] = color;
            q.push(&#123;xx, yy&#125;);
        &#125;
    &#125;
&#125;

void init()
&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= n; j++)
            cin &gt;&gt; a[i][j];
&#125;

int main()
&#123;
    init();
    bfs(0, 0, -1);
    
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= n; j++)
            if(a[i][j] == 0)
                bfs(i, j, 2);
    
    for(int i = 1; i &lt;= n; i++)
    &#123;
        for(int j = 1; j &lt;= n; j++)
        &#123;
            if(a[i][j] == -1) cout &lt;&lt; 0 &lt;&lt; &#39; &#39;;
            else cout &lt;&lt; a[i][j] &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h3 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3370">https://www.luogu.com.cn/problem/P3370</a></p>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>求不同的字符串的个数</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>首先用字符串哈希将字符串变为数字，将题目转化为求一个数组中有多少个不同的数即可。<br>均采用自然溢出的哈希方式</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;
using ull = unsigned long long;

const ull P = 13331, N = 10010, M = 1550;

int n;
ull a[N];
char s[M];

ull get_hash(char str[])
&#123;
    ull res = 0;
    for(int i = 0; str[i]; i++)
        res = res * P + str[i];
    return res;
&#125;

int main()
&#123;
    cin&gt;&gt;n;
    for(int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; s;
        a[i] = get_hash(s);
    &#125;
    sort(a, a + n);
    
    int res = 1;
    for(int i = 1; i &lt; n; i++)
        if(a[i] != a[i-1])
            res++;
    
    cout&lt;&lt;res;
&#125;
</code></pre>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h3 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2580">https://www.luogu.com.cn/problem/P2580</a></p>
<h3 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一份名单，再给定m组询问，每组询问回答该名字是否在名单中，以及是否已经被点过名。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>采用字符串哈希将名字转化为数字，由于有多组询问，我们可以将这一组数字以升序方式排序，然后二分查找即可。</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;
using ull = unsigned long long;

const ull P = 13331, N = 10010, M = 100;

int n, m;
ull a[N];
bool st[N];

char s[M];

ull get_hash(char str[])
&#123;
    ull res = 0;
    for(int i = 0; str[i]; i++)
        res = res * P + str[i];
    return res;
&#125;

int find(int l, int r, ull k)
&#123;
    while(l &lt;= r)
    &#123;
        int mid = (l + r) / 2;
        if(a[mid] == k) return mid;
        else if(a[mid] &lt; k) l = mid +1;
        else r = mid - 1;
    &#125;
    return -1;
&#125;

int main()
&#123;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; s;
        a[i] = get_hash(s);
    &#125;
    sort(a, a + n);
    
    cin &gt;&gt; m;
    while(m--)
    &#123;
        cin &gt;&gt; s;
        ull t = get_hash(s);
        int pos = find(0, n-1, t);
        if(pos == -1) 
            cout &lt;&lt; &quot;WRONG\n&quot;;
        else if(st[pos]) 
            cout &lt;&lt; &quot;REPEAT\n&quot;;
        else 
            cout &lt;&lt; &quot;OK\n&quot;, st[pos] = 1;
    &#125;
&#125;
</code></pre>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="题目链接-8"><a href="#题目链接-8" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1816">https://www.luogu.com.cn/problem/P1816</a></p>
<h3 id="题目大意-8"><a href="#题目大意-8" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个序列，再给定m组询问，对每组询问回答l-r区间的最小值。</p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>st表模板题</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 100010;

int n, m;

int f[N][18];

void init()
&#123;
    for(int j = 1; 1&lt;&lt;j &lt;= n; j++)
        for(int i = 1; i+(1&lt;&lt;j)-1 &lt;= n; i++)
            f[i][j] = min(f[i][j - 1], f[i + (1&lt;&lt;(j-1))][j - 1]);
&#125;

int get_min(int l, int r)
&#123;
    int k = log2(r - l + 1);
    return min(f[l][k], f[r-(1&lt;&lt;k) + 1][k]);
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)
        cin &gt;&gt; f[i][0];
    
    init();
    
    while(m--)
    &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        cout &lt;&lt; get_min(l, r) &lt;&lt; &#39; &#39;;
    &#125;
    
&#125;
</code></pre>
<h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><h3 id="题目链接-9"><a href="#题目链接-9" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4392">https://www.luogu.com.cn/problem/P4392</a></p>
<h3 id="题目大意-9"><a href="#题目大意-9" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一组长度为n的序列，输出所有满足以下条件的长度为m的子序列的起始坐标</p>
<ul>
<li>该子序列最大值减最小值小于等于阈值c</li>
</ul>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>用st表维护最大最小值，依次判断序列是否满足条件即可</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 1000010, M = 10010;

int n, m, c;
int fmx[N][14], fmn[N][14];


void init()
&#123;
    for(int j = 1; 1&lt;&lt;j &lt;= m; j++)
        for(int i = 1; i+(1&lt;&lt;j)-1 &lt;= n; i++)
            fmx[i][j] = max(fmx[i][j - 1], fmx[i + (1&lt;&lt;(j-1))][j-1]),
            fmn[i][j] = min(fmn[i][j - 1], fmn[i + (1&lt;&lt;(j-1))][j-1]);
&#125;

int get_max(int l, int r)
&#123;
    int k = log2(r - l + 1);
    return max(fmx[l][k], fmx[r - (1&lt;&lt;k) + 1][k]);
&#125;

int get_min(int l, int r)
&#123;
    int k = log2(r - l + 1);
    return min(fmn[l][k], fmn[r - (1&lt;&lt;k) + 1][k]);
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;
    for(int i = 1; i &lt;= n; i++)
        cin &gt;&gt; fmx[i][0], fmn[i][0] = fmx[i][0];
    
    init();
    
    bool have_mute = 0;
    for(int i = 1, j = m;j &lt;= n; i++, j++)
    &#123;
        if(get_max(i, j) - get_min(i, j) &lt;= c)
            cout&lt;&lt;i&lt;&lt;&#39;\n&#39;, have_mute = 1;
    &#125;
    if(!have_mute)
        cout&lt;&lt;&quot;NONE&quot;;
&#125;
</code></pre>
<h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><h3 id="题目链接-10"><a href="#题目链接-10" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1775/A2">https://codeforces.com/problemset/problem/1775/A2</a></p>
<h3 id="题目大意-10"><a href="#题目大意-10" class="headerlink" title="题目大意"></a>题目大意</h3><p>将一个字符串分成三个字符串a,b,c。使之满足以下条件之一：</p>
<ul>
<li>a&lt;&#x3D;b &amp;&amp; c&lt;&#x3D;b</li>
<li>a&gt;&#x3D;b &amp;&amp; c&gt;&#x3D;b</li>
</ul>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>首先判断字符串除首尾元素外是否有字符a，若有的话，那么字符a一定是字典序最小的，把字符串b设为这个字符a，剩余两部分给a和c即可，一定满足条件2.<br>若不含a，那么将除首尾元素的部分设为字符串b，这一部分也一定是字典序最大的，剩余首尾元素即是字符串a和c</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;

using namespace std;

const int N = 200010;

char s[N];

void solve()
&#123;
    cin &gt;&gt; s;
    int len = strlen(s);
    for(int i = 1; i &lt; len-1; i++)
    &#123;
        if(s[i] == &#39;a&#39;)
        &#123;
            for(int j = 0; j &lt; i; j++) cout &lt;&lt; s[j];
            cout &lt;&lt; &quot; a &quot;;
            for(int j = i + 1; j &lt; len; j++) cout &lt;&lt; s[j];
            cout &lt;&lt; &#39;\n&#39;;
            return;
        &#125;
    &#125;
    cout &lt;&lt; s[0] &lt;&lt; &#39; &#39;;
    for(int i = 1; i &lt; len-1; i++) cout &lt;&lt; s[i];
    cout &lt;&lt; &#39; &#39; &lt;&lt; s[len - 1] &lt;&lt; &#39;\n&#39;;
&#125;

int main()
&#123;
    int t = 1;
    
    cin &gt;&gt; t;
    while(t--)
        solve();
    
    return 0;
&#125;
</code></pre>
<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h3 id="题目链接-11"><a href="#题目链接-11" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1772/C">https://codeforces.com/problemset/problem/1772/C</a></p>
<h3 id="题目大意-11"><a href="#题目大意-11" class="headerlink" title="题目大意"></a>题目大意</h3><p>用小于等于k的正整数构造一个长度是n的严格上升的序列，使这个序列相邻两数不同的差的个数尽可能多</p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>优先以1,2,3……作为差值，直到若当前数与上一数的差值为d时无法满足后续序列严格上升时，将公差改为1.</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;

using namespace std;

void solve()
&#123;
    int k, n;
    cin &gt;&gt; k &gt;&gt; n;
    for(int i = 1, d = 0, elem = 1; i &lt;= k; i++)
    &#123;
        cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
        d++;
        if(n -(elem+d) &gt;= k-i-1)
            elem += d;
        else
            elem += 1;
    &#125;
    cout &lt;&lt; &#39;\n&#39;;
&#125;

int main()
&#123;
    int t;
    cin &gt;&gt; t;
    while(t--)
        solve();
&#125;
</code></pre>
<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h3 id="题目链接-12"><a href="#题目链接-12" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1741/B">https://codeforces.com/problemset/problem/1741/B</a></p>
<h3 id="题目大意-12"><a href="#题目大意-12" class="headerlink" title="题目大意"></a>题目大意</h3><p>构造一个长度为n的排列，满足以下要求：</p>
<ul>
<li>a[i]!&#x3D;i</li>
<li>对于a[i]，其相邻的数中至少有一个与其只差一</li>
</ul>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>当n等于2时，序列一定为 2,1<br>当n等于3时，序列一定不存在<br>当n大于等于4时，可以以如下方式构造序列，一定满足条件：<br>n-1,n,1,2,3……,n-2</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;

using namespace std;

void solve()
&#123;
    int n;
    cin&gt;&gt;n;
    
    if(n == 2)
        cout &lt;&lt; &quot;2 1\n&quot;;
    else if(n == 3)
        cout &lt;&lt; &quot;-1\n&quot;;
    else
    &#123;
        cout &lt;&lt; n-1 &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot;;
        for(int i = 1; i &lt;= n-2; i++)
            cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;

int main()
&#123;
    int t = 1;
    
    cin&gt;&gt;t;
    while(t--)
        solve();
&#125;
</code></pre>
<h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><h3 id="题目链接-13"><a href="#题目链接-13" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1741/A">https://codeforces.com/problemset/problem/1741/A</a></p>
<h3 id="题目大意-13"><a href="#题目大意-13" class="headerlink" title="题目大意"></a>题目大意</h3><p>比较两个尺码的大小，其中：</p>
<ul>
<li>含有L的&gt;含有M的&gt;含有S的</li>
<li>含有S的字符串中X越多，其尺码越小</li>
<li>含有L的字符串中X越多，其尺码越大</li>
</ul>
<h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>考虑字符串长度为len，将含L的len设为正数，含S的len设为负数，则含L字符串越长其大小越大，含S字符串越长其大小越小，满足条件。</p>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

const int N=55;

char a[N], b[N];

int get_size(char s[])
&#123;
    int len = strlen(s);
    char last_char = s[len - 1];
    if(last_char == &#39;M&#39;) return 0;
    else if(last_char == &#39;L&#39;) return len;
    else return -len;
&#125;

void solve()
&#123;
    cin &gt;&gt; a &gt;&gt; b;
    int s1 = get_size(a), s2 = get_size(b);
    if(s1 &lt; s2) cout &lt;&lt; &quot;&lt;\n&quot;;
    else if(s1 &gt; s2) cout &lt;&lt; &quot;&gt;\n&quot;;
    else cout &lt;&lt; &quot;=\n&quot;;
&#125;

int main()
&#123;
    int t=1;
    
    cin&gt;&gt;t;
    while(t--)
        solve();
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/BJFU寒假算法训练营/" style="color: #ffa2c4">
                BJFU寒假算法训练营
            </a>
        </span>
        
    </div>
    <a href="/2023/01/17/2023年BJFU寒假算法训练营DAY3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/01/13/BJFU-2023-集训队训练赛-4/">
        <h2 class="post-title">BJFU-2023-集训队训练赛-4</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/题解/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/1/13
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <span id="more"></span>

<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103427/problem/J">https://codeforces.com/gym/103427/problem/J</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个密码锁，问从abcd移动到efgh最少需要几步，每次可以转连续的齿轮，但每次只能走一步</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从abcd到efgh，其实转动的就是差值，相当于从0000走到一个状态C，状态C就是efgh-abcd的差值。因此我们可以从0000出发，跑bfs，得到从0000到所有状态的最短路，最后根据询问查表即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">map&lt;string,int&gt; mp;
queue&lt;string&gt; q;

string s1,s2;

void init()
&#123;
    q.push(&quot;0000&quot;);
    mp[&quot;0000&quot;]=0;
    while(q.size())
    &#123;
        string s=q.front();
        int step=mp[s];
        q.pop();
        for(int len=1;len&lt;=4;len++)     //每次转动几个齿轮
        &#123;
            for(int i=0,j=i+len-1;j&lt;4;i++,j++)  //齿轮边界
            &#123;
                string s1=s,s2=s;
                for(int k=i;k&lt;=j;k++)   //转动齿轮，一个向下转，一个向上转
                &#123;
                    s1[k]=(s1[k]-&#39;0&#39;+1)%10+&#39;0&#39;;
                    s2[k]=(s2[k]-&#39;0&#39;+9)%10+&#39;0&#39;;
                &#125;
                if(!mp.count(s1)) q.push(s1),mp[s1]=step+1;
                if(!mp.count(s2)) q.push(s2),mp[s2]=step+1;
            &#125;
        &#125;
    &#125;
&#125;
void input()
&#123;
    cin&gt;&gt;s1&gt;&gt;s2;
&#125;

void solve()
&#123;
    input();
    string s=&quot;0000&quot;;
    
    for(int i=0;i&lt;4;i++)
        s[i]=(s2[i]-s1[i]+10)%10+&#39;0&#39;;

    cout&lt;&lt;mp[s]&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/集训队训练赛/" style="color: #03a9f4">
                集训队训练赛
            </a>
        </span>
        
    </div>
    <a href="/2023/01/13/BJFU-2023-集训队训练赛-4/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/01/13/BJFU-2023-集训队训练赛-3/">
        <h2 class="post-title">BJFU-2023-集训队训练赛-3</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/题解/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/1/13
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <span id="more"></span>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1611/C">https://codeforces.com/problemset/problem/1611/C</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个变化后的序列b，求变化前的序列a，打印任意一种即可，a中元素互不相同，且范围为1-n，变化规则为：</p>
<ul>
<li>如果数列a最左端的元素小于最右端的元素，则将a的最左端元素放入数列b的最左端，如果数列a最右端的元素小于最左端的，则将最右端元素放入数列b的最右端</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先我们可以得知，n一定是最后进入序列b的，因此n一定出现在b的最左端或最右端，若未出现的话，则不可能变化成功。我们可以采用倒推，如果b的首部元素小于尾部，则将首部元素放回a的左端，若b的尾部元素小于首部，则将尾部元素放回a的右端，复原回去的a就满足条件。</p>
<pre><code class="cpp">int n;
list&lt;int&gt; a,ans;

void init()
&#123;
    a.clear();
    ans.clear();
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    &#123;
        int x;
        cin&gt;&gt;x;
        a.push_back(x);
    &#125;
&#125;

void solve()
&#123;
    init();
    if(a.front()==n||a.back()==n)
    &#123;
        while(!a.empty())
        &#123;
            if(a.front()&lt;a.back())
            &#123;
                ans.push_front(a.front());
                a.pop_front();
            &#125;
            else
            &#123;
                ans.push_back(a.back());
                a.pop_back();
            &#125;
        &#125;
        for(auto e:ans)
        &#123;
            cout&lt;&lt;e&lt;&lt;&#39; &#39;;
        &#125;
        cout&lt;&lt;&#39;\n&#39;;
    &#125;
    else
    &#123;
        cout&lt;&lt;&quot;-1\n&quot;;
    &#125;
&#125;
</code></pre>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1553/B">https://codeforces.com/problemset/problem/1553/B</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定两个字符串s1，s2，问s2能否通过下列规则得出</p>
<ul>
<li>在s1中选择一个位置pos，将其向右滑动k1，再向左滑动k2，滑过的所有字符依次组成s2，其中k1，k2&gt;&#x3D;0，如s1&#x3D;”abc”，s2可以为”abcba”</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>定义一个字符串为abcdefg，则在d点掉头的字符串一定可以在如下字符串中找到，abcdcba，因此我们可以将所有s1能产生的字符串记录，然后查询字符串中是否含有s2即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">string s1,s2;
vector&lt;string&gt; v;

void init()
&#123;
    cin&gt;&gt;s1&gt;&gt;s2;
    v.clear();
&#125;

void solve()
&#123;
    init();
    for(int i=1;i&lt;=s1.size();i++)
    &#123;
        string rs=s1.substr(0,i-1);
        reverse(rs.begin(),rs.end());
        v.push_back(s1.substr(0,i)+rs);
    &#125;
    for(const auto&amp; e:v)
    &#123;
        if(e.find(s2)!=string::npos)
        &#123;
            cout&lt;&lt;&quot;YES\n&quot;;
            return;
        &#125;
    &#125;
    cout&lt;&lt;&quot;NO\n&quot;;
&#125;
</code></pre>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1491/D">https://codeforces.com/problemset/problem/1491/D</a></p>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给全体自然数按照一下规则连有向边，问是否可以从a走到b，连边规则为：</p>
<ul>
<li>u-&gt;u+v,其中u&amp;v&#x3D;&#x3D;v</li>
</ul>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>通过模拟我们发现，u+v的二进制中含有的1的数量小于等于u，并且u+v在任意二进制位中u的后缀1数量都要大于等于u+v，这一点显然是可以递推的，因此，答案就是判断a和b是否满足上述关系即可。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int a,b;

void input()
&#123;
    cin&gt;&gt;a&gt;&gt;b;
&#125;

void solve()
&#123;
    input();
    if(a&gt;b)&#123;cout&lt;&lt;&quot;NO\n&quot;;return;&#125;
    int cnta=0,cntb=0;
    for(int i=0;i&lt;=31;i++)
    &#123;
        if(a&gt;&gt;i&amp;1) cnta++;
        if(b&gt;&gt;i&amp;1) cntb++;
        if(cnta&lt;cntb)
        &#123;
            cout&lt;&lt;&quot;NO\n&quot;;
            return;
        &#125;
    &#125;
    cout&lt;&lt;&quot;YES\n&quot;;
&#125;
</code></pre>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1490/C">https://codeforces.com/problemset/problem/1490/C</a></p>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数x，问是否能分解为a^3+b^3的形式，其中a,b&gt;0</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>假定a&gt;&#x3D;b，枚举a，如果a^3&gt;&#x3D;x或者2*a^3&lt;x，则都无法成立，否则，判断x-a^3是否为某一整数的三次方即可</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int x;

void init()
&#123;
    cin&gt;&gt;x;
&#125;

void solve()
&#123;
    init();
    for(int i=1;i&lt;=10000;i++)
    &#123;
        int i3=i*i*i;
        if(i3&gt;=x)&#123;cout&lt;&lt;&quot;NO\n&quot;;return;&#125;
        if(i3*2&lt;x) continue;
        int j3=x-i3;
        int j=round(pow(j3,1.0/3));
        if(j*j*j==j3)
        &#123;
            cout&lt;&lt;&quot;YES\n&quot;;
            return;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1486/B">https://codeforces.com/problemset/problem/1486/B</a></p>
<h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一组二维点，求到所有点的哈密尔顿距离之和最短的点的个数</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先判断一维点中哈密尔顿距离最短的情况。如果是奇数个点，则一定位于最中间的点，如a1,a2,a3,a4,a5，在a1至a5范围内距离都是a5-a1，在a2至a4范围内距离都是a4-a2，则想要使总距离最短，则此点必须与中心点距离最短，即0。若是偶数个点，则中间两个点的闭区间内距离都为最短，证明方法同上。二维中距离和最短的点的个数就是求出横坐标集和纵坐标集中距离最短的点的个数的乘积。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n;
int x[N],y[N];

void init()
&#123;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;x[i]&gt;&gt;y[i];
&#125;

void solve()
&#123;
    init();
    sort(x,x+n);
    sort(y,y+n);
    if(n&amp;1)
    &#123;
        cout&lt;&lt;1&lt;&lt;&#39;\n&#39;;
    &#125;
    else
    &#123;
        int nx=x[n/2]-x[n/2-1]+1;
        int ny=y[n/2]-y[n/2-1]+1;
        cout&lt;&lt;nx*ny&lt;&lt;&#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1482/B">https://codeforces.com/problemset/problem/1482/B</a></p>
<h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个序列，求最大的m，序列满足规则如下：</p>
<ul>
<li>a[1]&#x3D;s%m,a[i]&#x3D;(a[i-1]+c)%m</li>
<li>n&gt;0,m&gt;0,c&gt;&#x3D;0且c&lt;m,s&gt;&#x3D;0</li>
</ul>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>根据规则可以得出c&#x3D;(a[i+1]-a[i]+m)%m。首先用a[i+1]-a[i]，如果计算出c有两组以上的解，则不存在m。如果计算出两组解，若同为正或同为负，则也不存在，若一正一负，则可以得出m就是它们的差值。若只有一组解，则m可以取无穷大都满足。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n;
int a[N];
set&lt;int&gt; s;

void init()
&#123;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;a[i];
    s.clear();
&#125;

void solve()
&#123;
    init();
    for(int i=1;i&lt;n;i++)
        s.insert(a[i]-a[i-1]);
    if(s.size()&gt;2)
        cout&lt;&lt;&quot;-1\n&quot;;
    else if(s.size()==2)
    &#123;
        int x=*s.begin(),y=*(++s.begin());
        if(x*y&gt;=0) cout&lt;&lt;&quot;-1\n&quot;;
        else
        &#123;
            int m=0;
            if(x&gt;y) m=x-y;
            else m=y-x;
            for(int i=0;i&lt;n;i++)
                if(m&lt;=abs(a[i]))
                &#123;
                    cout&lt;&lt;&quot;-1\n&quot;;
                    return;
                &#125;
            cout&lt;&lt;m&lt;&lt;&#39; &#39;&lt;&lt;(a[1]-a[0]+m)%m&lt;&lt;&#39;\n&#39;;
        &#125;
    &#125;
    else
    &#123;
        cout&lt;&lt;&quot;0\n&quot;;
    &#125;
&#125;
</code></pre>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h3 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1478/B">https://codeforces.com/problemset/problem/1478/B</a></p>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n个整数和一个d，判断每一个整数能否分解为任意个含d的数。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>当整数a大于d*10后，一定可以取出来，因为一定能满足以下的分解形式，其中一个数是d*10+(a-d*10)%d,另外的所有数都是d。因此只需要开始处理出小于d*10的数能否成功分解即可。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">set&lt;int&gt; s[10];
int q,d;

void dfs(int k,int sum)
&#123;
    for(int i=k;i&lt;k*10;i+=10)
    &#123;
        int su=sum+i;
        if(su&gt;=k*10) continue;
        if(s[k].count(su)) continue;
        s[k].insert(su);
        dfs(k,su);
    &#125;
&#125;

void init()
&#123;
    for(int i=1;i&lt;=9;i++)
        dfs(i,0);
&#125;

void solve()
&#123;
    cin&gt;&gt;q&gt;&gt;d;
    while(q--)
    &#123;
        int a;
        cin&gt;&gt;a;
        if(a&gt;=d*10) cout&lt;&lt;&quot;YES\n&quot;;
        else
        &#123;
            if(s[d].count(a)) cout&lt;&lt;&quot;YES\n&quot;;
            else cout&lt;&lt;&quot;NO\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h3 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1461/B">https://codeforces.com/problemset/problem/1461/B</a></p>
<h3 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h3><p>问给定图形中含有多少个指定图形</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>我们可以发现，一个更大的指定图形可以由四个小的图形组成，因此可以考虑动态规划。设f[i][j]点表示指定图形在该点的最大边长，其中以指定图形的最中下部为基准，向单侧延伸的长度为边长。那么若f[i-1][j],f[i][j],f[i][j-1],f[i][j+1]中的值都大于等于x，则f[i][j]点更新为x+1</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n,m;
char a[N][N];
int f[N][N];

void init()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            cin&gt;&gt;a[i][j];
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            f[i][j]=(a[i][j]==&#39;*&#39;);
&#125;

void solve()
&#123;
    init();
    for(int k=2;k&lt;=(max(n,m)+1)/2;k++)
    for(int i=k;i&lt;=n;i++)
    &#123;
        for(int j=k;j&lt;=m-k+1;j++)
        &#123;
            if(f[i][j]&gt;=k-1&amp;&amp;f[i][j-1]&gt;=k-1&amp;&amp;f[i][j+1]&gt;=k-1&amp;&amp;f[i-1][j]&gt;=k-1)
                f[i][j]++;
        &#125;
    &#125;
    int ans=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            ans+=f[i][j];
    cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="题目链接-8"><a href="#题目链接-8" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1451/C">https://codeforces.com/problemset/problem/1451/C</a></p>
<h3 id="题目大意-8"><a href="#题目大意-8" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定字符串s1，s2，问能否通过如下转化规则使s1变为s2：</p>
<ul>
<li>可以任意交换s1中字符的顺序</li>
<li>相邻k个字符相同的话，则可以ascii值都+1</li>
</ul>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>只要有k个相同的字母，就可以将它们变为任意大于等于它们的字符。那么就可以让k个相等的字母为一组，其他剩余的字母不能改变。然后从字母a开始比较两个字符串中字母个数的差异。当且仅当前每一个字母都差k倍，且底层的字母能补充上层缺少的字母时，成立。</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n,k;
string s1,s2;
map&lt;char,int&gt; mp;

void init()
&#123;
    cin&gt;&gt;n&gt;&gt;k;
    cin&gt;&gt;s1&gt;&gt;s2;
    mp.clear();
&#125;

void solve()
&#123;
    init();
    int num=0;
    for(auto c:s1) mp[c]++;
    for(auto c:s2) mp[c]--;
    for(auto e:mp)
    &#123;
        //cout&lt;&lt;e.first&lt;&lt;&#39;:&#39;&lt;&lt;e.second&lt;&lt;&#39;\n&#39;;
        int nu=e.second;
        if(nu%k) &#123;cout&lt;&lt;&quot;NO\n&quot;;return;&#125;
        num+=nu/k;
        if(num&lt;0)&#123;cout&lt;&lt;&quot;NO\n&quot;;return;&#125;
    &#125;
    cout&lt;&lt;&quot;YES\n&quot;;
&#125;
</code></pre>
<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h3 id="题目链接-9"><a href="#题目链接-9" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1443/C">https://codeforces.com/problemset/problem/1443/C</a></p>
<h3 id="题目大意-9"><a href="#题目大意-9" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定两个长度为n的数组，表示分别表示外卖送达的时间和自己去取餐的时间，外卖可以同时叫，取餐只能一个一个去取，问所需要的最短时间。</p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>按照外卖时间排序，每一个外卖时间都可以作为一个分界线，小于当前外卖时间的都点外卖，剩余的自己取。自己取的时间可以用前缀和维护。</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">struct S
&#123;
    int a,b;
    bool operator&lt;(S r)
    &#123;
        return a&lt;r.a;
    &#125;
&#125;;
int n;
S a[N];
int s[N];

void init()
&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;a[i].a;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;a[i].b;
&#125;

void solve()
&#123;
    init();
    sort(a+1,a+1+n);
    for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i].b;
    int ans=2e9;
    for(int i=0;i&lt;=n;i++)
    &#123;
        ans=min(ans,max(s[n]-s[i],a[i].a));
    &#125;
    cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/集训队训练赛/" style="color: #03a9f4">
                集训队训练赛
            </a>
        </span>
        
    </div>
    <a href="/2023/01/13/BJFU-2023-集训队训练赛-3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/01/12/BJFU-2023-集训队训练赛-2/">
        <h2 class="post-title">BJFU-2023-集训队训练赛-2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/题解/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/1/12
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <span id="more"></span>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1552/B">https://codeforces.com/problemset/problem/1552/B</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有n个人，每个人有过去五场比赛的名次，问是否有人在这场比赛中能赢过所有人，赢过一个人的条件是在过去的五场比赛中排名比他高至少三次</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要判断是否会有运动员获得奖牌，只要判断最有可能的运动员能否获得奖牌即可，那我们可以用快排来将最有可能的人放在最前面，再判断是否符合即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">struct p
&#123;
    int ord;
    int sco[M];
    bool operator&lt;(p r)
    &#123;
        int win=0;
        for(int i=0;i&lt;5;i++)
            if(sco[i]&lt;r.sco[i])
                win++;
        return win&gt;=3;
    &#125;
&#125;;

int n;
p a[N];

void init()
&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    &#123;
        a[i].ord=i;
        for(int j=0;j&lt;M;j++)
            cin&gt;&gt;a[i].sco[j];
    &#125;
&#125;

void solve()
&#123;
    init();
    sort(a+1,a+1+n);
    for(int i=2;i&lt;=n;i++)
    &#123;
        if(!(a[1]&lt;a[i]))
        &#123;
            cout&lt;&lt;&quot;-1\n&quot;;
            return;
        &#125;
    &#125;
    cout&lt;&lt;a[1].ord&lt;&lt;&#39;\n&#39;;
    
&#125;
</code></pre>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1551/C">https://codeforces.com/problemset/problem/1551/C</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n个只含有a,b,c,d,e的单词，在这n个单词中选择最大数目的单词，其中选择的单词需要满足如下规则：</p>
<ul>
<li>这些单词中某一个字母的数量要大于其他单词的数量和</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>枚举每一种选择的字母，优先选择单词中这个字母数减其他字母数的差最大的单词，直到差值和小于等于零时，就不能选择了。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">struct S
&#123;
    int num[M];
    int tot;
    bool operator&lt;(S r)
    &#123;
        return num[base]-(tot-num[base])&gt;r.num[base]-(r.tot-r.num[base]);
    &#125;
&#125;;

int n;
S a[N];

void init()
&#123;
    cin&gt;&gt;n;
    string s;
    for(int i=0;i&lt;n;i++)
    &#123;
        cin&gt;&gt;s;
        for(int j=0;j&lt;5;j++)
            a[i].num[j]=0;
        for(auto e:s)
            a[i].num[e-&#39;a&#39;]++;
        a[i].tot=s.size();
    &#125;
&#125;

void solve()
&#123;
    init();
    int ans=0;
    for(base=0;base&lt;M;base++)
    &#123;
        sort(a,a+n);
        int dif=0;
        for(int i=0;i&lt;n;i++)
        &#123;
            dif+=a[i].num[base]-(a[i].tot-a[i].num[base]);
            if(dif&lt;=0)
            &#123;
                ans=max(ans,i);
                break;
            &#125;
        &#125;
        if(dif&gt;0) ans=n;
    &#125;
    cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1548/A">https://codeforces.com/problemset/problem/1548/A</a></p>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n个节点和m个边<br>接下来会有q次操作</p>
<ul>
<li>在u，v间添加一条边，保证此前u，v间无边</li>
<li>在u，v间移除一条边，保证此前u，v间有边</li>
<li>表示执行以下操作直至不可再执行为止。定义一个人的强度为其编号。在每个 大小大于 1 的连通块中找到强度最小的人，将这个人及其所连的边一同删去。在所有操作执行完毕后，请你输出还剩下多少人。注意，每个 3 操作之间彼此独立。即删人只是暂时的，这次操作结束之后所有被删的人连同边会复活。</li>
</ul>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们可以考虑什么人会存活到最后，1是独立的人，2是比相连的所有点都大，那么可以统一为一个信息，就是周围比它大的点数为0。因此我们可以统计每一个点周围比它大的点的个数。在统计时没有必要遍历一遍，我们只需统计这个信息从0变为1和从1变为0时的变化即可，从0变为1说明又有一个点要被删除，从1变为0说明又多了一个点存活下来。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n,m,q;
int cnt[N];
int num=0;

void init()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        if(a&gt;b) swap(a,b);
        if(!cnt[a]) num++;
        cnt[a]++;
    &#125;
&#125;

void solve()
&#123;
    init();
    cin&gt;&gt;q;
    while(q--)
    &#123;
        int op,u,v;
        cin&gt;&gt;op;
        if(op==1)
        &#123;
            cin&gt;&gt;u&gt;&gt;v;
            if(u&gt;v) swap(u,v);
            if(!cnt[u])
                num++;
            cnt[u]++;
        &#125;
        else if(op==2)
        &#123;
            cin&gt;&gt;u&gt;&gt;v;
            if(u&gt;v) swap(u,v);
            cnt[u]--;
            if(!cnt[u])
                num--;
        &#125;
        else
        &#123;
            cout&lt;&lt;n-num&lt;&lt;&#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1527/B1">https://codeforces.com/problemset/problem/1527/B1</a></p>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个只含有0，1的回文串，两个人依次进行如下操作，问游戏结束后谁的花费最低</p>
<ul>
<li>选择一个0变为1，花费1</li>
<li>若当前不是回文串，则可以翻转该回文串，花费为0</li>
<li>当全为1后，游戏结束</li>
</ul>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>首先考虑含有偶数个0的情况，当Alice先手后，Bob可以选择在对称位置也改为1，依次进行，直到最后一个0时，Bob可以选择翻转字符串，让Alice再花费1，所以Bob必胜。接下来考虑奇数个1的情况，当只有1个1时，Bob必胜，否则，Alice选择把中间的0改为1，然后当Bob下完后，Alice在对称位置改为1，直到最后一个1时，Alice选择翻转字符串，就可以让Bob最终比自己多花费1，Alice获胜。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n;
char s[N];

void init()
&#123;
    cin&gt;&gt;n&gt;&gt;s;
&#125;

void solve()
&#123;
    init();
    int t=0;
    for(int i=0;i&lt;n;i++)
        if(s[i]==&#39;0&#39;)
            t++;
    if(t&amp;1)
    &#123;
        if(t==1) cout&lt;&lt;&quot;BOB\n&quot;;
        else cout&lt;&lt;&quot;ALICE\n&quot;;
    &#125;
    else
    &#123;
        cout&lt;&lt;&quot;BOB\n&quot;;
    &#125;
&#125;
</code></pre>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1521/B">https://codeforces.com/problemset/problem/1521/B</a></p>
<h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个长度为n的序列，使其变为Good，序列为Good的条件为相邻两数互质，你可以进行的操作为</p>
<ul>
<li>选择两个数x,y，改变它们为x’，y’，其中min(x,y)&#x3D;&#x3D;min(x’,y’)<br>你最多可以进行n次操作</li>
</ul>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>我们可以知道，k和k+1互质，所以，我们可以选择序列中最小的数m为基准，使整个序列变为如下形式：m+3，m+2,m+1,m,m+1,m+2,m+3.m+4即可，每次改变m和一个其他数，就可以保证更改前后最小数一定是m</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n;
int a[N];

void init()
&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;a[i];
&#125;

void solve()
&#123;
    init();
    cout&lt;&lt;n-1&lt;&lt;&#39;\n&#39;;
    int idx=1;
    for(int i=2;i&lt;=n;i++)
    &#123;
        if(a[i]&lt;a[idx]) idx=i;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(idx==i) continue;
        cout&lt;&lt;idx&lt;&lt;&#39; &#39;&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;a[idx]&lt;&lt;&#39; &#39;&lt;&lt;a[idx]+abs(i-idx)&lt;&lt;&#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1520/A">https://codeforces.com/problemset/problem/1520/A</a></p>
<h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个序列，求是否存在同一种字符出现在不连续的位置，如：ABA不连续，AAB连续</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>当出现一个字符在之前出现过后，判断这个字符的前一个字符是否和它相同，不相同的话就一定是不连续的</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n;
char s[N];
set&lt;char&gt; st;

void init()
&#123;
    cin&gt;&gt;n&gt;&gt;s;
    st.clear();
&#125;

void solve()
&#123;
    init();
    for(int i=0;i&lt;n;i++)
    &#123;
        if(!st.count(s[i]))
            st.insert(s[i]);
        else
        &#123;
            if(s[i-1]!=s[i])
            &#123;
                cout&lt;&lt;&quot;NO\n&quot;;
                return;
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;&quot;YES\n&quot;;
&#125;
</code></pre>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h3 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1514/C">https://codeforces.com/problemset/problem/1514/C</a></p>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>在[1,2,…,n-1]中选择任意个数，使得它们的乘积%n&#x3D;&#x3D;1，打印出任一答案即可</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>首先我们令乘积为m，则m%n&#x3D;&#x3D;1可以推出gcd(m,n)&#x3D;&#x3D;1（见证明1）,然后我们就可以求出所有与n互质的数，将它们乘起来模n，若结果不为1，则将结果w去除即可，w肯定在与n互质的数中（见证明2）</p>
<blockquote>
<p>证明1：反证法，假设m,n不互质，则gcd(m,n)&#x3D;&#x3D;d(d&gt;1)。m%n&#x3D;&#x3D;1可以表示为m&#x3D;&#x3D;n*k+1,令m&#x3D;ad，n&#x3D;bd，则ad&#x3D;nbd+1,(a-nb)d&#x3D;&#x3D;1,由于a，b，n，d都为整数，且d&gt;1，则此式不成立，所以证得若m%n&#x3D;&#x3D;1,则gcd(m,n)&#x3D;&#x3D;1</p>
</blockquote>
<blockquote>
<p>证明2：gcd(m,n)&#x3D;&#x3D;1,则gcd(m%n,n)&#x3D;&#x3D;1,则gcd(w,n)&#x3D;&#x3D;1，由于w&lt;n，所以w在与n互质的数中</p>
</blockquote>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n;
set&lt;int&gt; ans;

int gcd(int x,int y)&#123;return y?gcd(y,x%y):x;&#125;

void init()
&#123;
    cin&gt;&gt;n;
&#125;

void solve()
&#123;
    init();
    int m=1;
    for(int i=1;i&lt;n;i++)
        if(gcd(i,n)==1)
            ans.insert(i),m=m*i%n;
    if(m&gt;1) ans.erase(m);
    cout&lt;&lt;ans.size()&lt;&lt;&#39;\n&#39;;
    for(auto e:ans)
        cout&lt;&lt;e&lt;&lt;&#39; &#39;;
&#125;
</code></pre>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h3 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1512/D">https://codeforces.com/problemset/problem/1512/D</a></p>
<h3 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n+2长度的序列，是否能选择其中n个数，使得这n个数的和等于剩余两个数中的其中一个</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>剩余的两个数只可能是序列中次大或最大的。若是次大的，则一定是前n个数，判断是否相等即可。若是最大的，则剩余的一个数一定是前面所有数的和减去最大数，判断是否存在这样一个数即可。</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n;
int a[N];
void init()
&#123;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n+2;i++)
    &#123;
        cin&gt;&gt;a[i];
    &#125;
&#125;

void solve()
&#123;
    init();
    int tot=0;
    sort(a,a+n+2);
    for(int i=0;i&lt;n;i++)
        tot+=a[i];
    if(tot==a[n])
    &#123;
        for(int i=0;i&lt;n;i++)
            cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;
        cout&lt;&lt;&#39;\n&#39;;
        return;
    &#125;
    tot+=a[n];
    int delidx=-1;
    for(int i=0;i&lt;n+1;i++)
    &#123;
        if(tot-a[i]==a[n+1])
            delidx=i;
    &#125;
    if(delidx==-1)
    &#123;
        cout&lt;&lt;&quot;-1\n&quot;;
        return;
    &#125;
    for(int i=0;i&lt;n+1;i++)
    &#123;
        if(i==delidx) continue;
        cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;
    &#125;
    cout&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>
<h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><h3 id="题目链接-8"><a href="#题目链接-8" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1594/D">https://codeforces.com/problemset/problem/1594/D</a></p>
<h3 id="题目大意-8"><a href="#题目大意-8" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n个人和m个描述，描述信息是a描述b是诚实者&#x2F;说谎者，问在这种情况下说谎者最多是几个</p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>若a描述b是诚实者，则a和b身份相同。若a描述b是说谎者，则a和b身份相反。可以用并查集来维护，身份相同则在一个集合中，否则不在一个集合。若一个集合中出现了矛盾，则输出-1。</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">const int N=200010,M=500010;

int n,m;
int x[M],y[M];
bool same[M];
int p[N*2],sz[N*2];

char s[30];

int find(int x)
&#123;
    if(p[x]==x) return p[x];
    p[x]=find(p[x]);
    sz[p[x]]+=sz[x];
    sz[x]=0;
    return p[x];
&#125;

void merge(int a,int b)
&#123;
    int pa=find(a),pb=find(b);
    if(pa==pb) return;
    p[pa]=pb;
    sz[pb]+=sz[pa];
    sz[pa]=0;
&#125;

void init()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;s;
        if(*s==&#39;c&#39;) same[i]=1;
        else same[i]=0;
    &#125;
    for(int i=1;i&lt;=n*2;i++)
        p[i]=i;
    for(int i=1;i&lt;=n;i++)
        sz[i]=1;
    for(int i=n+1;i&lt;=n*2;i++)
        sz[i]=0;
&#125;

void solve()
&#123;
    init();
    for(int i=1;i&lt;=m;i++)
    &#123;
        if(same[i])
            merge(x[i],y[i]),merge(x[i]+n,y[i]+n);
        else
            merge(x[i],y[i]+n),merge(x[i]+n,y[i]);
    &#125;
    int ans=0;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(find(i)==find(i+n))
        &#123;
            cout&lt;&lt;&quot;-1\n&quot;;
            return;
        &#125;
        ans+=max(sz[find(i)],sz[find(i+n)]);
        sz[find(i)]=0;
        sz[find(i+n)]=0;
    &#125;
    cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
    
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/集训队训练赛/" style="color: #00bcd4">
                集训队训练赛
            </a>
        </span>
        
    </div>
    <a href="/2023/01/12/BJFU-2023-集训队训练赛-2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/01/10/BJFU-2023-集训队训练赛-1/">
        <h2 class="post-title">BJFU-2023-集训队训练赛-1</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/题解/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/1/10
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <span id="more"></span>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1220/C">https://codeforces.com/problemset/problem/1220/C</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定字符串s，在一定规则下，求出每一次由谁获胜</p>
<p>规则如下：</p>
<ul>
<li>k为起始l和r的坐标，k从0到strlen(s)</li>
<li>每一次可以将l和r移动到l’和r’，其中l’&lt;&#x3D;l,r’&gt;&#x3D;r，并且s[l’,r’]的字典序要小于s[l,r]</li>
<li>Ann先移动</li>
<li>谁无法移动谁就输了</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们考虑当什么情况下可以移动，如果l前面存在一个数l’，使得s[l’]&lt;s[l]，则可以移动，否则无法移动。因此，若想要自己尽可能能赢，则一定会选择l’，使得l’尽可能小，则下一个人一定无法移动。因此，题目就可以转化为初始时Ann是否可以移动，若Ann可以移动，则一定可以移动到l’，使得在s[l’]最小时，l’最小，Mike无法移动，则Ann获胜，若Ann初始时Ann无法移动，则Mike获胜。因此，题目可以进一步转化为是否存在l’，满足l’&lt;k,且s[l’]&lt;s[k]。我们可以存储前0到k-1中最小的ascii值，判断是否小于当前的s[k]，若小于，则Ann赢，否则，Mike赢。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">char s[500010];

void solve()
&#123;
    cin&gt;&gt;s;
    char m=s[0];
    cout&lt;&lt;&quot;Mike\n&quot;;
    for(int i=1;s[i];i++)
    &#123;
        m=min(m,s[i-1]);
        if(s[i]&lt;=m)
            cout&lt;&lt;&quot;Mike\n&quot;;
        else
            cout&lt;&lt;&quot;Ann\n&quot;;
    &#125;
&#125;
</code></pre>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1092/D1">https://codeforces.com/problemset/problem/1092/D1</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一堵墙的每一处的高度，判断我们是否可以通过使用2*1的砖，使这堵墙水平</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们可以考虑2*1的砖竖直放置时可以使得一堵墙成为每一处高度只差1的情况，如2,1,1,4,5可以变为6,5,5,6,5，也就相当于0,1,1,0,1。如何判断是否可以水平呢，我们发现，如果相邻两个数相等，则一定可以转化为任意高度，就可以忽略这两堵墙，如果这两处墙左右两边的墙高度也一致，则一定可以使这四处墙高度一致，因此我们可以使用栈来判断相邻处奇偶性。</p>
<pre><code class="cpp">int n;
int a[N];
int sta[N],top;

void init()
&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
    for(int i=1;i&lt;=n;i++) a[i]&amp;=1;
&#125;

void solve()
&#123;
    init();
    for(int i=1;i&lt;=n;i++)
    &#123;
        sta[++top]=a[i];
        while(top&gt;=2&amp;&amp;sta[top]==sta[top-1]) top-=2;
    &#125;
    if(top&gt;1)
        cout&lt;&lt;&quot;NO\n&quot;;
    else
        cout&lt;&lt;&quot;YES\n&quot;;
&#125;
</code></pre>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1481/C">https://codeforces.com/problemset/problem/1481/C</a></p>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定篱笆的颜色，新篱笆的颜色，以及每一个粉刷匠携带的颜色，其中粉刷匠按给定顺序来，并且每一个粉刷匠必须且只能喷一扇篱笆，问是否可以得到新篱笆的颜色，若可以，则输出每一个粉刷匠喷的篱笆是哪一个</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>由于前面来的没有用的粉刷匠都可以让他们喷到后面会被再次喷的篱笆上，就可以使这些粉刷匠不污染颜色，因此我们从后往前找粉刷匠。优先喷与原篱笆颜色不符的篱笆，如果喷完后还有原篱笆的颜色与新篱笆不同，则一定失败。还有一种情况是比如当前面所有粉刷匠喷完篱笆后已经完全相同了，最后一个粉刷匠拿着一个与前面都不同的颜色，那一定失败。我们可以在喷完必须喷的颜色后，找到未喷的粉刷匠中与新色彩一致的满足条件的最后一个粉刷匠，如果在这个粉刷匠之前，就可以喷到这个粉刷匠粉刷的篱笆上，否则，就失败。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n,m;
int a[N],b[N],c[N];
int ans[N];
multimap&lt;int,int&gt; mp;   //储存必须喷的篱笆，第一个int是颜色，第二个是坐标
map&lt;int,int&gt; mp2;       //储存新老篱笆颜色相同的篱笆，每种颜色只存储一个即可，int信息同上
void init()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++) ans[i]=0;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i];
    for(int i=1;i&lt;=m;i++) cin&gt;&gt;c[i];
    mp.clear();
    mp2.clear();
    for(int i=n;i&gt;=1;i--)
        if(a[i]!=b[i])
            mp.insert(&#123;b[i],i&#125;);
        else
            if(!mp2.count(b[i]))
                mp2.insert(&#123;b[i],i&#125;);
&#125;

void solve()
&#123;
    init();
    int mx_ord=-1,idx;
    for(int i=m;i&gt;=1;i--)   //从后往前喷必须喷的
    &#123;
        auto it=mp.find(c[i]);
        if(it!=mp.end())
        &#123;
            ans[i]=it-&gt;second;
            if(mx_ord&lt;i)
            &#123;
                mx_ord=i;
                idx=it-&gt;second;
            &#125;
            mp.erase(it);
        &#125;
    &#125;
    if(mp.size())   //如果还有需要喷的，则一定失败
    &#123;
        cout&lt;&lt;&quot;NO\n&quot;;
        return;
    &#125;
    for(int i=m;i&gt;=1;i--)   //从后往前给剩余未喷的粉刷匠找目标
    &#123;
        if(ans[i]) continue;
        if(i&lt;mx_ord)
        &#123;
            ans[i]=idx;
            continue;
        &#125;
        auto it=mp2.find(c[i]);
        if(it!=mp2.end())
        &#123;
            ans[i]=it-&gt;second;
            if(mx_ord&lt;i)
            &#123;
                mx_ord=i;
                idx=it-&gt;second;
            &#125;
            continue;
        &#125;
        else
        &#123;
            cout&lt;&lt;&quot;NO\n&quot;;
            return;
        &#125;
    &#125;
    cout&lt;&lt;&quot;YES\n&quot;;
    for(int i=1;i&lt;=m;i++)
        cout&lt;&lt;ans[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;&quot;\n&quot;;
&#125;
</code></pre>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1481/B">https://codeforces.com/problemset/problem/1481/B</a></p>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>有n座高分别为hi的山，你需要进行k次操作，求出第k次操作结束后你的坐标，操作如下</p>
<ul>
<li>每次操作开始时，你在第一座山</li>
<li>如果下一座山高度&lt;&#x3D;你所在山，则你到下一座山</li>
<li>如果下一座山高度&gt;你所在山，则你让当前山高度加一，回到起点，本次操作结束</li>
<li>如果到最后第n座山没有拦住你，则你的坐标为-1</li>
</ul>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>纯模拟题，无需思路</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n,k;
int h[105];

void init()
&#123;
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;h[i];
&#125;

void solve()
&#123;
    init();
    h[n+1]=-1;
    for(int i=1;i&lt;=k;i++)
    &#123;
        for(int j=1;j&lt;=n+1;j++)
        &#123;
            if(j==n+1)
            &#123;
                cout&lt;&lt;-1&lt;&lt;&#39;\n&#39;;
                return;
            &#125;
            if(h[j]&lt;h[j+1])
            &#123;
                if(i==k)
                &#123;
                    cout&lt;&lt;j&lt;&lt;&#39;\n&#39;;
                    return;
                &#125;
                h[j]++;
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/796/B">https://codeforces.com/problemset/problem/796/B</a></p>
<h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n个杯子，m个洞和k次操作，给一个小球，初始时在1处，每次操作交换坐标为a,b的杯子。如果小球在的位置有洞，则掉进洞中，不再改变位置。求小球最后所在的位置。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>纯模拟，用set记录洞的位置，每次判断是否在洞中即可</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n,m,k;
set&lt;int&gt; hole;

void init()
&#123;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    while(m--)
    &#123;
        int x;
        cin&gt;&gt;x;
        hole.insert(x);
    &#125;
&#125;

void solve()
&#123;
    int pos=1;
    bool in_hole=0;
    init();
    while(k--)
    &#123;
        if(hole.count(pos)) in_hole=1;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        if(!in_hole)
        &#123;
            if(pos==x)
                pos=y;
            else if(pos==y)
                pos=x;
        &#125;
    &#125;
    cout&lt;&lt;pos&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>
<h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1474/A">https://codeforces.com/problemset/problem/1474/A</a></p>
<h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个长度为n的字符串b，求字符串a，满足以下规则</p>
<ul>
<li>a,b长度相等，且只含有0,1，但这不是二进制</li>
<li>使a+b尽可能大，但是，a+b中如果相邻的数相等，则会只保留一个</li>
</ul>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>贪心，使最高位尽可能的大。之后的位和前一个位比较，如果a为1时与前一位不同，则a为1，否则为0，这样就可以保证在高位尽可能大时不会发生合并</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">char s[100010];
void solve()
&#123;
    int n;
    cin&gt;&gt;n&gt;&gt;s;
    s[0]++;
    cout&lt;&lt;1;
    for(int i=1;i&lt;n;i++)
    &#123;
        if(s[i]+1!=s[i-1])
        &#123;
            cout&lt;&lt;1;
            s[i]++;
        &#125;
        else
        &#123;
            cout&lt;&lt;0;
        &#125;
    &#125;
    cout&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>
<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h3 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1474/B">https://codeforces.com/problemset/problem/1474/B</a></p>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定t个数d，对每一个d，求出一个最小的数a，其中a的因子个数大于等于4，且a的任意因子的差值大于等于d</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>a一定包含1和a本身，因此只需要再找出两个因子即可。若这两个因子中有非质因子仍满足条件，则只含其质因子也一定满足条件，所以两个因子都是质因子。可以用任意素数筛预处理出需要的素数，然后找到两个素数满足题目表述即可</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">const int N=1000000;
int prime[100000],sz;
bool is_prime[N];

void init() //预处理素数，写在主函数即可
&#123;
    memset(is_prime,1,sizeof is_prime);
    is_prime[0]=0,is_prime[1]=0;
    for(int i=2;i&lt;N;i++)
    &#123;
        if(is_prime[i])
        &#123;
            prime[sz++]=i;
            for(int j=i+i;j&lt;N;j+=i)
            &#123;
                is_prime[j]=0;
            &#125;
        &#125;
    &#125;
&#125;

void solve()
&#123;
    int d,a,b;
    cin&gt;&gt;d;
    int i=0;
    while(prime[i]-1&lt;d)
        i++;
    a=prime[i];
    while(prime[i]-a&lt;d)
        i++;
    b=prime[i];
    cout&lt;&lt;(long long)a*b&lt;&lt;&#39;\n&#39;; //保险起见开long long
&#125;
</code></pre>
<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h3 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1474/C">https://codeforces.com/problemset/problem/1474/C</a></p>
<h3 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个长度为n*2的数列，问是否存在一个数x，使得数列能清空，若可以，给出x和每一次的清除元素，清空规则如下：</p>
<ul>
<li>选择两个数a,b,使得a+b&#x3D;&#x3D;x，清除a，b，并将x改为max(a,b)</li>
<li>继续执行，直到数列为空</li>
</ul>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>由于x满足a+b&#x3D;&#x3D;x，所以，每一次的x一定大于剩余数列中最大的数。因此，当确定x后，我们每次一定取剩余数列中最大数a和另一个数x-a，并将x改为a。当结束之前，我们无法在数列中取到x-a时，说明初始x不合法。确定检验x规则后，我们可以枚举所有可能的x，判断是否有成立的若都不成立，则不存在。x一定是初始数列中最大数和一个其他元素的和。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">int n;
int a[2010];

vector&lt;pii&gt; check(int mx)
&#123;
    vector&lt;pii&gt; ans;
    multiset&lt;int&gt; ms;
    for(int i=0;i&lt;2*n;i++)
        ms.insert(a[i]);
    for(int i=0;i&lt;n;i++)
    &#123;
        auto e=*(--ms.end());
        ms.erase(--ms.end());
        auto it=ms.find(mx-e);
        if(it==ms.end())
            return &#123;&#125;;
        ans.push_back(&#123;mx-e,e&#125;);
        ms.erase(it);
        mx=e;
    &#125;
    return ans;
&#125;

void solve()
&#123;
    cin&gt;&gt;n;
    for(int i=0;i&lt;2*n;i++)
        cin&gt;&gt;a[i];
    sort(a,a+2*n);
    for(int i=2*n-2;i&gt;=0;i--)
    &#123;
        auto ans=check(a[i]+a[2*n-1]);
        if(ans.empty()) continue;
        cout&lt;&lt;&quot;YES\n&quot;;
        cout&lt;&lt;a[i]+a[2*n-1]&lt;&lt;&#39;\n&#39;;
        for(auto e:ans)
        &#123;
            cout&lt;&lt;e.first&lt;&lt;&#39; &#39;&lt;&lt;e.second&lt;&lt;&#39;\n&#39;;
        &#125;
        return;
    &#125;
    cout&lt;&lt;&quot;NO&quot;&lt;&lt;&#39;\n&#39;;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/集训队训练赛/" style="color: #ff7d73">
                集训队训练赛
            </a>
        </span>
        
    </div>
    <a href="/2023/01/10/BJFU-2023-集训队训练赛-1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/01/08/AtCoder Beginner Contest-284/">
        <h2 class="post-title">AtCoder Beginner Contest 284</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/题解/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/1/8
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <span id="more"></span>

<h3 id="原题链接：戳这里"><a href="#原题链接：戳这里" class="headerlink" title="原题链接：戳这里"></a>原题链接：<a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc284">戳这里</a></h3><hr>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>读入N个字符串，然后倒序输出</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用vector，stack等容器实现</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;

vector&lt;string&gt; v;

int main()
&#123;
    int n;
    cin&gt;&gt;n;
    while(n--)
    &#123;
        string s;
        cin&gt;&gt;s;
        v.push_back(s);
    &#125;
    for(auto it=v.rbegin();it!=v.rend();it++)
        cout&lt;&lt;*it&lt;&lt;endl;
&#125;
</code></pre>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定T组数据，对于每组数据，有N个整数，求出这N个整数中奇数的个数</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>奇数即%2余1的数</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;

void solve()
&#123;
    int n,ans=0;
    cin&gt;&gt;n;
    while(n--)
    &#123;
        int x;
        cin&gt;&gt;x;
        if(x&amp;1)
            ans++;
    &#125;
    cout&lt;&lt;ans&lt;&lt;endl;
&#125;

int main()
&#123;
    int t;
    cin&gt;&gt;t;
    while(t--)
        solve();
&#125;
</code></pre>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定N个点和M条边，求有多少个连通块</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>用并查集来维护，初始有N个连通块，每当有两个不在一个集合内的点连一条边时，连通块的个数减一</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;

using namespace std;

int p[105];
int find(int x)
&#123;
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
&#125;

int main()
&#123;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    int ans=n;
    for(int i=1;i&lt;=n;i++) p[i]=i;
    while(m--)
    &#123;
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        int pa=find(a),pb=find(b);
        if(pa!=pb)
            p[pa]=pb,ans--;
    &#125;
    cout&lt;&lt;ans;
&#125;
</code></pre>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定T组数据，对于每组数据，有一个整数N，N可以被分解成p^2*q的形式，其中p和q都是质数，求p和q</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>N的范围到达10^18次方，因此最差时间复杂度也基本是三次根号下N。考虑到N的形式，我们只需找到一个N的因子t，即可得到p和q，因为若t是p，则q是N&#x2F;(t*t);若t是q，则p是sqrt(N&#x2F;t)。那么问题就转移为了如何求出N的最小因子。考虑当N的最小因子最大时，也不过10^6级别，因为N&#x3D;p^2*q,若N的最小因子大于10^6，则N大于10^18。所以只需要从2开始枚举，找到第一个因子即可，时间复杂度为O(三次根号下N)。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
using ll=long long;
void solve()
&#123;
    ll n;
    ll p,q;
    cin&gt;&gt;n;
    for(ll i=2;;i++)
    &#123;
        if(n%i==0)
        &#123;
            ll t=n/i;
            if(t%i==0)  //如果n是i*i的倍数，则i就是p
            &#123;
                p=i;
                q=t/i;
            &#125;
            else
            &#123;
                q=i;
                p=sqrt(t);  //由于有精度问题，所以要找到正确的，或者此处可以写成round(sqrt(t));
                if(p*p&lt;t) p++;
                if(p*p&gt;t) p--;
            &#125;
            break;
        &#125;
    &#125;
    cout&lt;&lt;p&lt;&lt;&#39; &#39;&lt;&lt;q&lt;&lt;endl;
&#125;

int main()
&#123;
    int t;
    cin&gt;&gt;t;
    while(t--)
        solve();
&#125;
</code></pre>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定N个点和M条边，定义从1出发的路径数量为K，求min(K,10^6)。其中路径上不能有重复的点。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>图的dfs，通过手动模拟即可很容易了解</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using  namespace std;

const int N=200010,M=N*2;

int h[N],e[M],ne[M],idx;
bool st[N];

int n,m;
int ans;

void add(int a,int b)
&#123;
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
&#125;

void dfs(int x)
&#123;
    if(ans&gt;=1000000) return;
    if(st[x]) return;   //当该点在路径当中时就不能使用
    st[x]=1;
    ans++;
    for(int i=h[x];i!=-1;i=ne[i])
    &#123;
        int j=e[i];
        dfs(j);
    &#125;
    st[x]=0;    //回溯，该点结束后可能有其他路线再次经过该点
&#125;

int main()
&#123;
    memset(h,-1,sizeof h);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;m;i++)
    &#123;
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);
        add(b,a);
    &#125;
    
    dfs(1);
    
    cout&lt;&lt;ans;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AtCoder/" style="color: #00bcd4">
                AtCoder
            </a>
        </span>
        
    </div>
    <a href="/2023/01/08/AtCoder Beginner Contest-284/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/06/学生出入校管理系统/">
        <h2 class="post-title">学生出入校管理系统</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/项目/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                项目
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/12/6
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>大一上学期C程序设计课课设,现在感觉整体架构不是很好,但也懒得再重构了www</p>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00bcd4">
                C
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/作业/" style="color: #ff7d73">
                作业
            </a>
        </span>
        
    </div>
    <a href="/2022/12/06/学生出入校管理系统/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/03/无聊的数列/">
        <h2 class="post-title">无聊的数列</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/题解/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/12/3
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>一道裸的线段树,需要考虑对区间修改的方式如何进行转化</p>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/洛谷/" style="color: #00a596">
                洛谷
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/蓝/" style="color: #00bcd4">
                蓝
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/线段树/" style="color: #00bcd4">
                线段树
            </a>
        </span>
        
    </div>
    <a href="/2022/12/03/无聊的数列/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/03/The Child and Sequence/">
        <h2 class="post-title">The Child and Sequence</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/题解/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/12/3
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>一棵裸的线段树,需要思考如何实现区间取模操作</p>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/蓝/" style="color: #ff7d73">
                蓝
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/codeforces/" style="color: #ff7d73">
                codeforces
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/线段树/" style="color: #ff7d73">
                线段树
            </a>
        </span>
        
    </div>
    <a href="/2022/12/03/The Child and Sequence/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <i class="fa-solid fa-caret-right fa-fw"></i>
            </span>
        </a>
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="/img/images/head_portrait.jpg " alt="avatar">
        </div>
        <div class="name">
            Yhs_Joker
        </div>
        <div class="descriptions">
            
            <div class="description">
                未来目标:区域赛拿牌
            </div>
            
            <div class="description">
                春季目标：CF紫名, AtCoder青名, 蓝桥杯国奖
            </div>
            
        </div>
        <div class="icon-links">
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2023 Yhs_JokerのBlog
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Yhs_Joker
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>