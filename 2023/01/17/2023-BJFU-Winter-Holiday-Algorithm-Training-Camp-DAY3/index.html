
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>2023年BJFU寒假算法训练营DAY3 | Yhs_JokerのBlog</title>
        <meta name="author" content="Yhs_Joker" />
        <meta name="description" content="There is only one kind of heroism in the world, which is to love life after knowing the truth of life." />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YHS_JOKERのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YHS_JOKERのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>2023年BJFU寒假算法训练营DAY3</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/1/17
        </span>
        
        <span class="category">
            <a href="/categories/%E9%A2%98%E8%A7%A3/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                题解
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/BJFU%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/" style="color: #03a9f4">BJFU寒假算法训练营</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4913">https://www.luogu.com.cn/problem/P4913</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>求二叉树的深度</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本代码采用朴素建树方式，即每一个节点存储其左右儿子节点下标<br>dfs：求出两个子树的深度，那么该树的深度就是最大子树深度+1<br>bfs：记录父节点深度，下一层深度为当前节点深度+1，到叶子节点时更新最大深度</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;
using pii=pair&lt;int,int&gt;;

const int N = 1e6+10;

struct node
&#123;
    int ord, l, r;  //ord： 节点编号  l：左儿子下标  r：右儿子下标
&#125;;

int n;
node tr[N]; //建树

void init()
&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)
    &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        tr[i] = &#123;i, l, r&#125;;
    &#125;
&#125;

int dfs(int u)
&#123;
    if(tr[u].ord == 0)  //空节点没有深度
        return 0;
    return max(dfs(tr[u].l), dfs(tr[u].r)) + 1;
&#125;

int bfs(int u)
&#123;
    int max_depth = 0;
    
    queue&lt;pii&gt; q;
    q.push(&#123;u, 1&#125;);
    while(!q.empty())
    &#123;
        pii t = q.front();
        q.pop();
        
        int ord = t.first, depth = t.second;
        
        if(tr[ord].l==0 &amp;&amp; tr[ord].r==0) &#123;max_depth = max(max_depth, depth); continue;&#125;
        if(tr[ord].l) q.push(&#123;tr[ord].l, depth + 1&#125;);
        if(tr[ord].r) q.push(&#123;tr[ord].r, depth + 1&#125;);
    &#125;
    
    return max_depth;
&#125;

int main()
&#123;
    init();
    //cout &lt;&lt; dfs(1);
    cout &lt;&lt; bfs(1);
&#125;
</code></pre>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1364">https://www.luogu.com.cn/problem/P1364</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>选择一个点，使这个点到其他所有点的距离乘权重之和最小</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题采用邻接表建树<br>由于数据范围很小，因此我们可以枚举每一个点，求出以该点为医院的距离和，更新最小距离和。dfs方式为返回该节点及其子树的距离和。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include&lt;cstring&gt;

using namespace std;

const int N = 110, M =210; 

int h[N], w[N], e[M], ne[M], idx;

void add(int u, int v)
&#123;
    e[idx] = v;
    ne[idx] = h[u];
    h[u] = idx++;
&#125;

int dfs(int u, int fa, int dist)
&#123;
    int tot_dist = w[u] * dist;
    for(int i = h[u]; ~i; i = ne[i])
    &#123;
        int j = e[i];
        if(j != fa) tot_dist += dfs(j, u, dist + 1);
    &#125;
    return tot_dist;
&#125;

int n;

void init()
&#123;
    memset(h, -1, sizeof h);
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)
    &#123;
        int u, v;
        cin &gt;&gt; w[i] &gt;&gt; u &gt;&gt; v;
        if(u) add(i, u), add(u, i);
        if(v) add(i, v), add(v, i);
    &#125;
&#125;

int main()
&#123;
    init();
    int res = 0x3f3f3f3f;
    for(int i = 1; i &lt;= n; i++)
        res = min(res, dfs(i, 0, 0));
    cout &lt;&lt; res;
&#125;
</code></pre>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2853">https://www.luogu.com.cn/problem/P2853</a></p>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>求所有牛可以到达的点的个数</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对每头牛能走到的地方记录，如果某一点被记录了n次（n为牛的个数），那么这个点就是一个所有牛可以走到的点。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include&lt;cstring&gt;

using namespace std;

const int K = 105, N = 1005, M = 10005;

int a[K];
int h[N], e[M], ne[M], idx;
bool st[N];     //记录某一头牛能走到的点
int num[N];     //记录该点能被几头牛走到

int k,n,m;

void add(int a, int b)
&#123;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
&#125;

void init()
&#123;
    memset(h, -1, sizeof h);
    cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; k; i++)
        cin &gt;&gt; a[i];
    for(int i = 0; i &lt; m; i++)
    &#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
    &#125;
&#125;

void dfs(int u, int fa)
&#123;
    if(st[u]) return;   //如果已经走过该点，就不需要再走一遍了
    st[u] = 1;
    num[u]++;
    for(int i = h[u]; ~i; i=ne[i])
    &#123;
        int j = e[i];
        dfs(j, u);
    &#125;
&#125;

int main()
&#123;
    init();
    
    for(int i = 0; i &lt; k; i++)
    &#123;
        memset(st, 0, sizeof st);
        dfs(a[i], 0);
    &#125;
    
    int res = 0;
    
    for(int i = 1; i &lt;= n; i++)
        if(num[i] == k)
            res++;
    
    cout&lt;&lt;res;
&#125;
</code></pre>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8604">https://www.luogu.com.cn/problem/P8604</a></p>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定起点和终点，若失去某一点后无法从起点走到终点，那么称这一点为危险点。求危险点的个数。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>如果某一个点为危险点，那么从起点走到终点的过程中一定会经过。因此可以dfs遍历所有从起点到终点的路径，若某一点被经过的次数等于路径条数，那么该点就是危险点。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 1005, M = 2005;

int h[N], e[M * 2], ne[M * 2], idx;
int num[N]; //某点被经过的次数
bool st[N]; //某点是否被经过

int n, m;
int tot, orig, dest;

void add(int u, int v)
&#123;
    e[idx] = v;
    ne[idx] = h[u];
    h[u] = idx++;
&#125;

void dfs(int u)
&#123;
    if(st[u]) return;
    if(u == dest)   //到达终点
    &#123;
        tot++;  //路径条数变化
        for(int i=1; i &lt;= n; i++)   //将该路径下经过的点记入次数
            num[i] += st[i];
        return;
    &#125;
    st[u] = 1;  //在该路径下不能重复经过某一点
    for(int i = h[u]; ~i; i=ne[i])
    &#123;
        int j = e[i];
        dfs(j);
    &#125;
    st[u] = 0;  //走过该点后，就可以再次走该点
&#125;

void init()
&#123;
    memset(h, -1, sizeof h);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; m; i++)
    &#123;
        int u, v;
        cin &gt;&gt; u &gt;&gt;v;
        add(u, v);
        add(v, u);
    &#125;
    cin &gt;&gt; orig &gt;&gt; dest;
&#125;

int main()
&#123;
    init();
    dfs(orig);
    
    int res = 0;
    for(int i = 1; i &lt;= n; i++)
        if(num[i] == tot)
            res++;

    cout &lt;&lt; res - 1;
&#125;
</code></pre>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1443">https://www.luogu.com.cn/problem/P1443</a></p>
<h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>求马走到每一个点最少需要几步</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>bfs模板题，注意不要越界</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;

using namespace std;
using pii = pair&lt;int, int&gt;;

const int N = 405;

int n, m, x, y;
int dist[N][N];

int move_x[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;, move_y[8] = &#123;-1, -2, -2, -1, 1, 2, 2, 1&#125;;

void bfs()
&#123;
    queue&lt;pii&gt; q;
    dist[x][y] = 0;
    q.push(&#123;x, y&#125;);
    while(!q.empty())
    &#123;
        pii t = q.front();
        q.pop();
        int x = t.first, y = t.second;
        for(int i = 0; i &lt; 8; i++)
        &#123;
            int xx = x + move_x[i], yy = y + move_y[i];
            if(xx &lt; 1 || xx &gt; n) continue;
            if(yy &lt; 1 || yy &gt; m) continue;
            if(dist[xx][yy] != -1) continue;
            dist[xx][yy] = dist[x][y] + 1;
            q.push(&#123;xx, yy&#125;);
        &#125;
    &#125;
&#125;

void init()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++)
            dist[i][j] = -1;
&#125;

int main()
&#123;
    init();
    bfs();
    for(int i = 1; i &lt;= n; i++)
    &#123;
        for(int j = 1; j &lt;= m; j++)
        &#123;
            printf(&quot;%-5d&quot;, dist[i][j]);     //除非你很清楚你在做什么，否则不要将cin/cout和scanf/printf混用
        &#125;
        printf(&quot;\n&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1162">https://www.luogu.com.cn/problem/P1162</a></p>
<h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>将封闭图形内部的0变为2</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>先将外围的0变为别的数，再将剩余的0变为2。可以选择任意搜索方式</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;
using pii = pair&lt;int, int&gt;;

const int N = 40;

int n;
int a[N][N];

int move_x[4] = &#123;1, 0, -1, 0&#125;, move_y[4] = &#123;0, -1, 0, 1&#125;;

void bfs(int x, int y, int color)
&#123;
    queue&lt;pii&gt; q;
    a[x][y] = color;
    q.push(&#123;x,y&#125;);
    while(!q.empty())
    &#123;
        pii t = q.front();
        q.pop();
        int x = t.first, y = t.second;
        for(int i = 0; i &lt; 4; i++)
        &#123;
            int xx = x + move_x[i], yy = y + move_y[i];
            if(xx &lt; 0 || xx &gt; n+1) continue;
            if(yy &lt; 0 || yy &gt; n+1) continue;
            if(a[xx][yy] != 0) continue;
            a[xx][yy] = color;
            q.push(&#123;xx, yy&#125;);
        &#125;
    &#125;
&#125;

void init()
&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= n; j++)
            cin &gt;&gt; a[i][j];
&#125;

int main()
&#123;
    init();
    bfs(0, 0, -1);
    
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= n; j++)
            if(a[i][j] == 0)
                bfs(i, j, 2);
    
    for(int i = 1; i &lt;= n; i++)
    &#123;
        for(int j = 1; j &lt;= n; j++)
        &#123;
            if(a[i][j] == -1) cout &lt;&lt; 0 &lt;&lt; &#39; &#39;;
            else cout &lt;&lt; a[i][j] &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h3 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3370">https://www.luogu.com.cn/problem/P3370</a></p>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>求不同的字符串的个数</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>首先用字符串哈希将字符串变为数字，将题目转化为求一个数组中有多少个不同的数即可。<br>均采用自然溢出的哈希方式</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;
using ull = unsigned long long;

const ull P = 13331, N = 10010, M = 1550;

int n;
ull a[N];
char s[M];

ull get_hash(char str[])
&#123;
    ull res = 0;
    for(int i = 0; str[i]; i++)
        res = res * P + str[i];
    return res;
&#125;

int main()
&#123;
    cin&gt;&gt;n;
    for(int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; s;
        a[i] = get_hash(s);
    &#125;
    sort(a, a + n);
    
    int res = 1;
    for(int i = 1; i &lt; n; i++)
        if(a[i] != a[i-1])
            res++;
    
    cout&lt;&lt;res;
&#125;
</code></pre>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h3 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2580">https://www.luogu.com.cn/problem/P2580</a></p>
<h3 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一份名单，再给定m组询问，每组询问回答该名字是否在名单中，以及是否已经被点过名。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>采用字符串哈希将名字转化为数字，由于有多组询问，我们可以将这一组数字以升序方式排序，然后二分查找即可。</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;
using ull = unsigned long long;

const ull P = 13331, N = 10010, M = 100;

int n, m;
ull a[N];
bool st[N];

char s[M];

ull get_hash(char str[])
&#123;
    ull res = 0;
    for(int i = 0; str[i]; i++)
        res = res * P + str[i];
    return res;
&#125;

int find(int l, int r, ull k)
&#123;
    while(l &lt;= r)
    &#123;
        int mid = (l + r) / 2;
        if(a[mid] == k) return mid;
        else if(a[mid] &lt; k) l = mid +1;
        else r = mid - 1;
    &#125;
    return -1;
&#125;

int main()
&#123;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; s;
        a[i] = get_hash(s);
    &#125;
    sort(a, a + n);
    
    cin &gt;&gt; m;
    while(m--)
    &#123;
        cin &gt;&gt; s;
        ull t = get_hash(s);
        int pos = find(0, n-1, t);
        if(pos == -1) 
            cout &lt;&lt; &quot;WRONG\n&quot;;
        else if(st[pos]) 
            cout &lt;&lt; &quot;REPEAT\n&quot;;
        else 
            cout &lt;&lt; &quot;OK\n&quot;, st[pos] = 1;
    &#125;
&#125;
</code></pre>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="题目链接-8"><a href="#题目链接-8" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1816">https://www.luogu.com.cn/problem/P1816</a></p>
<h3 id="题目大意-8"><a href="#题目大意-8" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个序列，再给定m组询问，对每组询问回答l-r区间的最小值。</p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>st表模板题</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 100010;

int n, m;

int f[N][18];

void init()
&#123;
    for(int j = 1; 1&lt;&lt;j &lt;= n; j++)
        for(int i = 1; i+(1&lt;&lt;j)-1 &lt;= n; i++)
            f[i][j] = min(f[i][j - 1], f[i + (1&lt;&lt;(j-1))][j - 1]);
&#125;

int get_min(int l, int r)
&#123;
    int k = log2(r - l + 1);
    return min(f[l][k], f[r-(1&lt;&lt;k) + 1][k]);
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)
        cin &gt;&gt; f[i][0];
    
    init();
    
    while(m--)
    &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        cout &lt;&lt; get_min(l, r) &lt;&lt; &#39; &#39;;
    &#125;
    
&#125;
</code></pre>
<h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><h3 id="题目链接-9"><a href="#题目链接-9" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4392">https://www.luogu.com.cn/problem/P4392</a></p>
<h3 id="题目大意-9"><a href="#题目大意-9" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一组长度为n的序列，输出所有满足以下条件的长度为m的子序列的起始坐标</p>
<ul>
<li>该子序列最大值减最小值小于等于阈值c</li>
</ul>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>用st表维护最大最小值，依次判断序列是否满足条件即可</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 1000010, M = 10010;

int n, m, c;
int fmx[N][14], fmn[N][14];


void init()
&#123;
    for(int j = 1; 1&lt;&lt;j &lt;= m; j++)
        for(int i = 1; i+(1&lt;&lt;j)-1 &lt;= n; i++)
            fmx[i][j] = max(fmx[i][j - 1], fmx[i + (1&lt;&lt;(j-1))][j-1]),
            fmn[i][j] = min(fmn[i][j - 1], fmn[i + (1&lt;&lt;(j-1))][j-1]);
&#125;

int get_max(int l, int r)
&#123;
    int k = log2(r - l + 1);
    return max(fmx[l][k], fmx[r - (1&lt;&lt;k) + 1][k]);
&#125;

int get_min(int l, int r)
&#123;
    int k = log2(r - l + 1);
    return min(fmn[l][k], fmn[r - (1&lt;&lt;k) + 1][k]);
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;
    for(int i = 1; i &lt;= n; i++)
        cin &gt;&gt; fmx[i][0], fmn[i][0] = fmx[i][0];
    
    init();
    
    bool have_mute = 0;
    for(int i = 1, j = m;j &lt;= n; i++, j++)
    &#123;
        if(get_max(i, j) - get_min(i, j) &lt;= c)
            cout&lt;&lt;i&lt;&lt;&#39;\n&#39;, have_mute = 1;
    &#125;
    if(!have_mute)
        cout&lt;&lt;&quot;NONE&quot;;
&#125;
</code></pre>
<h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><h3 id="题目链接-10"><a href="#题目链接-10" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1775/A2">https://codeforces.com/problemset/problem/1775/A2</a></p>
<h3 id="题目大意-10"><a href="#题目大意-10" class="headerlink" title="题目大意"></a>题目大意</h3><p>将一个字符串分成三个字符串a,b,c。使之满足以下条件之一：</p>
<ul>
<li>a&lt;&#x3D;b &amp;&amp; c&lt;&#x3D;b</li>
<li>a&gt;&#x3D;b &amp;&amp; c&gt;&#x3D;b</li>
</ul>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>首先判断字符串除首尾元素外是否有字符a，若有的话，那么字符a一定是字典序最小的，把字符串b设为这个字符a，剩余两部分给a和c即可，一定满足条件2.<br>若不含a，那么将除首尾元素的部分设为字符串b，这一部分也一定是字典序最大的，剩余首尾元素即是字符串a和c</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;

using namespace std;

const int N = 200010;

char s[N];

void solve()
&#123;
    cin &gt;&gt; s;
    int len = strlen(s);
    for(int i = 1; i &lt; len-1; i++)
    &#123;
        if(s[i] == &#39;a&#39;)
        &#123;
            for(int j = 0; j &lt; i; j++) cout &lt;&lt; s[j];
            cout &lt;&lt; &quot; a &quot;;
            for(int j = i + 1; j &lt; len; j++) cout &lt;&lt; s[j];
            cout &lt;&lt; &#39;\n&#39;;
            return;
        &#125;
    &#125;
    cout &lt;&lt; s[0] &lt;&lt; &#39; &#39;;
    for(int i = 1; i &lt; len-1; i++) cout &lt;&lt; s[i];
    cout &lt;&lt; &#39; &#39; &lt;&lt; s[len - 1] &lt;&lt; &#39;\n&#39;;
&#125;

int main()
&#123;
    int t = 1;
    
    cin &gt;&gt; t;
    while(t--)
        solve();
    
    return 0;
&#125;
</code></pre>
<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h3 id="题目链接-11"><a href="#题目链接-11" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1772/C">https://codeforces.com/problemset/problem/1772/C</a></p>
<h3 id="题目大意-11"><a href="#题目大意-11" class="headerlink" title="题目大意"></a>题目大意</h3><p>用小于等于k的正整数构造一个长度是n的严格上升的序列，使这个序列相邻两数不同的差的个数尽可能多</p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>优先以1,2,3……作为差值，直到若当前数与上一数的差值为d时无法满足后续序列严格上升时，将公差改为1.</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;

using namespace std;

void solve()
&#123;
    int k, n;
    cin &gt;&gt; k &gt;&gt; n;
    for(int i = 1, d = 0, elem = 1; i &lt;= k; i++)
    &#123;
        cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
        d++;
        if(n -(elem+d) &gt;= k-i-1)
            elem += d;
        else
            elem += 1;
    &#125;
    cout &lt;&lt; &#39;\n&#39;;
&#125;

int main()
&#123;
    int t;
    cin &gt;&gt; t;
    while(t--)
        solve();
&#125;
</code></pre>
<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h3 id="题目链接-12"><a href="#题目链接-12" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1741/B">https://codeforces.com/problemset/problem/1741/B</a></p>
<h3 id="题目大意-12"><a href="#题目大意-12" class="headerlink" title="题目大意"></a>题目大意</h3><p>构造一个长度为n的排列，满足以下要求：</p>
<ul>
<li>a[i]!&#x3D;i</li>
<li>对于a[i]，其相邻的数中至少有一个与其只差一</li>
</ul>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>当n等于2时，序列一定为 2,1<br>当n等于3时，序列一定不存在<br>当n大于等于4时，可以以如下方式构造序列，一定满足条件：<br>n-1,n,1,2,3……,n-2</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;iostream&gt;

using namespace std;

void solve()
&#123;
    int n;
    cin&gt;&gt;n;
    
    if(n == 2)
        cout &lt;&lt; &quot;2 1\n&quot;;
    else if(n == 3)
        cout &lt;&lt; &quot;-1\n&quot;;
    else
    &#123;
        cout &lt;&lt; n-1 &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot;;
        for(int i = 1; i &lt;= n-2; i++)
            cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;

int main()
&#123;
    int t = 1;
    
    cin&gt;&gt;t;
    while(t--)
        solve();
&#125;
</code></pre>
<h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><h3 id="题目链接-13"><a href="#题目链接-13" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1741/A">https://codeforces.com/problemset/problem/1741/A</a></p>
<h3 id="题目大意-13"><a href="#题目大意-13" class="headerlink" title="题目大意"></a>题目大意</h3><p>比较两个尺码的大小，其中：</p>
<ul>
<li>含有L的&gt;含有M的&gt;含有S的</li>
<li>含有S的字符串中X越多，其尺码越小</li>
<li>含有L的字符串中X越多，其尺码越大</li>
</ul>
<h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>考虑字符串长度为len，将含L的len设为正数，含S的len设为负数，则含L字符串越长其大小越大，含S字符串越长其大小越小，满足条件。</p>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

const int N=55;

char a[N], b[N];

int get_size(char s[])
&#123;
    int len = strlen(s);
    char last_char = s[len - 1];
    if(last_char == &#39;M&#39;) return 0;
    else if(last_char == &#39;L&#39;) return len;
    else return -len;
&#125;

void solve()
&#123;
    cin &gt;&gt; a &gt;&gt; b;
    int s1 = get_size(a), s2 = get_size(b);
    if(s1 &lt; s2) cout &lt;&lt; &quot;&lt;\n&quot;;
    else if(s1 &gt; s2) cout &lt;&lt; &quot;&gt;\n&quot;;
    else cout &lt;&lt; &quot;=\n&quot;;
&#125;

int main()
&#123;
    int t=1;
    
    cin&gt;&gt;t;
    while(t--)
        solve();
&#125;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Yhs_JokerのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Yhs_Joker
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="yhsjoker/yhsjoker.github.io"
    data-repo-id="R_kgDOIchRxw"
    data-category="Announcements"
    data-category-id="DIC_kwDOIchRx84CZAz1"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
