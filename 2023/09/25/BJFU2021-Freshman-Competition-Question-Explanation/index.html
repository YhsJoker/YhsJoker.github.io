
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>BJFU2021新生赛题解 | Yhs_JokerのBlog</title>
        <meta name="author" content="Yhs_Joker" />
        <meta name="description" content="There is only one kind of heroism in the world, which is to love life after knowing the truth of life." />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YHS_JOKERのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YHS_JOKERのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>BJFU2021新生赛题解</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/9/25
        </span>
        
        <span class="category">
            <a href="/categories/%E9%A2%98%E8%A7%A3/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                题解
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%96%B0%E7%94%9F%E8%B5%9B/" style="color: #ffa2c4">新生赛</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="A-Hello-World-复现"><a href="#A-Hello-World-复现" class="headerlink" title="A Hello World 复现"></a>A Hello World 复现</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/A.png" alt="A"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>签到题。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main()&#123;
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; &quot;Hello World &quot; &lt;&lt; n;
&#125;
</code></pre>
<h2 id="B-OJ的包围"><a href="#B-OJ的包围" class="headerlink" title="B OJ的包围"></a>B OJ的包围</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/B.jpeg" alt="B"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>模拟题，由外向内逐层填字符即可。</p>
<p>可以提前处理出来每一层的字符来化简代码量。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

const int N = 60;
const char s[] = &quot; OJabcdefghijklmnopqrstuvwxyz&quot;;

int n;
char g[N][N];

void solve()&#123;
    cin &gt;&gt; n;
    
    for(int i = 1, j = n; i &lt;= j; i++, j--)&#123;
        for(int k = i; k &lt;= j; k++)&#123;
            g[i][k] = g[k][i] = g[j][k] = g[k][j] = s[i];
        &#125;
    &#125;

    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= n; j++)&#123;
            cout &lt;&lt; g[i][j] &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="C-JJR的神奇克隆机器"><a href="#C-JJR的神奇克隆机器" class="headerlink" title="C JJR的神奇克隆机器"></a>C JJR的神奇克隆机器</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/C.png" alt="C"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>由于原本数量初始为 $1$ ，因此</p>
<ul>
<li><p>当 $y&#x3D;0$ 时，答案一定为 <code>NO</code> 。</p>
</li>
<li><p>当 $y&#x3D;1$ 时，无法进行复制复制品操作，此时只有 $x&#x3D;0$ 合法 。</p>
</li>
<li><p>当 $y&gt;1$ 时，由于获得原本操作只能通过操作 $1$ 实现，因此我们优先进行操作 $1$ 来得到 $y$ 本原本。若复制品不够，则使用操作 $2$ 来增加复制品个数。那么，此时会出现几个问题</p>
<ul>
<li>当获得 $y$ 本原本后，复制品个数大于 $x$ ，则无法实现。</li>
<li>当获得 $y$ 本原本后，复制品个数小于等于 $x$ ，若此时复制品个数与 $x$ 差值为奇数，则无法通过操作 $2$ 得到恰好 $x$ 本。</li>
</ul>
</li>
</ul>
<p>注意本题需要使用 <code>long long</code> 。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

ll x, y;

void solve()&#123;
    
    cin &gt;&gt; x &gt;&gt; y;
    if(y == 0)&#123;
        cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
    &#125;
    else if(y == 1)
    &#123;
        if(x == 0)&#123;
            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &#39;\n&#39;;
        &#125;
        else&#123;
            cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    else&#123;
        int delta = x - (y - 1);
        if(delta &lt; 0)&#123;
            cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
        &#125;
        else&#123;
            if(delta &amp; 1)&#123;
                cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
            &#125;
            else&#123;
                cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &#39;\n&#39;;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="D-贝塔的难题"><a href="#D-贝塔的难题" class="headerlink" title="D 贝塔的难题"></a>D 贝塔的难题</h2><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/D.jpeg" alt="D"></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>首先求出每两个数的 $gcd$ ，然后排序即可。</p>
<p>求解 $gcd$ 可以使用 <code>__gcd(int a, int b)</code> 函数，也可以自己手写一个 $gcd$ 函数：</p>
<pre><code class="cpp">int gcd(int a, int b)&#123;
    return b ? gcd(b, a % b) : a;
&#125;
</code></pre>
<p>从大到小排序可以使用 <code>greater&lt;int&gt;()</code> ，也可以手写一个比较器：</p>
<pre><code class="cpp">bool cmp(int lhs, int rhs)&#123;
    return lhs &gt; rhs;
&#125;
</code></pre>
<p>注意本题需要使用 $long\ long$ 。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
//	cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

const int N = 1e5 + 10;

ll n, res[N];

void solve()&#123;
    cin &gt;&gt; n;
    
    for(int i = 0; i &lt; n; i++)&#123;
        ll a, b;
        cin &gt;&gt; a &gt;&gt; b;
        res[i] = __gcd(a, b);
    &#125;
    
    sort(res, res + n, greater&lt;ll&gt;());
    
    for(int i = 0; i &lt; n; i++)&#123;
        cout &lt;&lt; res[i];
    &#125;
    
&#125;
</code></pre>
<h2 id="E-星尘斗士"><a href="#E-星尘斗士" class="headerlink" title="E 星尘斗士"></a>E 星尘斗士</h2><h3 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/E.jpeg" alt="E"></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>模拟题，学会使用结构体排序即可。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

const int N = 1e5 + 10;

struct Person&#123;
    string s;
    int a, d;
    
    bool operator &lt; (const Person &amp;rhs)&#123;
        if(a != rhs.a) return a &gt; rhs.a;
        return d &gt; rhs.d;
    &#125;
&#125;;

int n, m;
Person people[N];

void solve()&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i++)&#123;
        string s;
        int a, d;
        cin &gt;&gt; s &gt;&gt; a &gt;&gt; d;
        people[i] = &#123;s, a, d&#125;;
    &#125;
    
    sort(people, people + n);
    
    for(int i = 0; i &lt; m; i++)&#123;
        cout &lt;&lt; people[i].s &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="F-图书馆前的水坑"><a href="#F-图书馆前的水坑" class="headerlink" title="F 图书馆前的水坑"></a>F 图书馆前的水坑</h2><h3 id="题面-5"><a href="#题面-5" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/F.jpeg" alt="F"></p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>经典的 $Flood\ Fill$ 算法，使用 $bfs$ 或 $dfs$ 填满遇到的水坑。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
//	cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

const int N = 105;

int n, m;
char g[N][N];

void dfs(int x, int y)&#123;
    if(g[x][y] == &#39;X&#39;) return;
    g[x][y] = &#39;X&#39;;
    for(int dx = -1; dx &lt;= 1; dx++)&#123;
        for(int dy = -1; dy &lt;= 1; dy++)&#123;
            dfs(x + dx, y + dy);
        &#125;
    &#125;
&#125;

void solve()&#123;
    memset(g, &#39;X&#39;, sizeof g);
    
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            cin &gt;&gt; g[i][j];
        &#125;
    &#125;
    
    int res = 0;
    
    for(int i = 1; i &lt;= n; i++)&#123;
        for(int j = 1; j &lt;= m; j++)&#123;
            if(g[i][j] == &#39;O&#39;)&#123;
                dfs(i, j);
                res++;
            &#125;
        &#125;
    &#125;
    
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h2 id="G-泰罗的复仇"><a href="#G-泰罗的复仇" class="headerlink" title="G 泰罗的复仇"></a>G 泰罗的复仇</h2><h3 id="题面-6"><a href="#题面-6" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/G.jpeg" alt="G"></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>考虑贪心，对于所有可以攻击的怪兽，优先攻击生命值低的怪兽，从而可以让我们击败最多数量的怪兽。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
//	cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

const int N = 5005;

int n, p, h, b;
int hp[N], idx = 0;

void solve()&#123;
    cin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; b;
    for(int i = 0; i &lt; n; i++)&#123;
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        if(h + b &gt;= x)&#123;
            hp[idx++] = y;
        &#125;
    &#125;
    
    sort(hp, hp + idx);
    
    int res = 0;
    for(int i = 0; i &lt; idx; i++)&#123;
        if(p &gt;= hp[i])&#123;
            p -= hp[i];
            res++;
        &#125;
    &#125;
    
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h2 id="H-小明的烦恼"><a href="#H-小明的烦恼" class="headerlink" title="H 小明的烦恼"></a>H 小明的烦恼</h2><h3 id="题面-7"><a href="#题面-7" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/H.jpeg" alt="H"></p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>根据欧拉回路定理，该图存在欧拉回路，因此答案为所有路径的和。</p>
<p>四舍五入使用如下方式：</p>
<pre><code class="cpp">double res;
cout &lt;&lt; (int)(res + 0.5) &lt;&lt; &#39;\n&#39;;
//本题中使用round(res)会导致wrong answer，暂时不知道原因。
</code></pre>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;
using db = double;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
//	cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

db dist(db x1, db y1, db x2, db y2)&#123;
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
&#125;

void solve()&#123;
    db x1, y1, x2, y2, res = 0;
    cin &gt;&gt; x1 &gt;&gt; y1;
    
    while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)&#123;
        res += dist(x1, y1, x2, y2);
    &#125;
    
    cout &lt;&lt; (int)(2 * res + 0.5) &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h2 id="I-奇奇偶偶"><a href="#I-奇奇偶偶" class="headerlink" title="I 奇奇偶偶"></a>I 奇奇偶偶</h2><h3 id="题面-8"><a href="#题面-8" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/I.jpeg" alt="I"></p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>首先考虑数列中奇数和偶数的个数 $oddnum$ ， $evennum$ ，若 $abs(oddnum - evennum)&gt;1$ ，则一定无法实现操作。</p>
<p>否则，</p>
<p>若 $oddnum&gt;evennum$ ，则序列一定为 <code>odd even odd even odd</code> 这样的形式。若 $oddnum&gt;evennum$ ，则为 <code>even odd even odd even</code> 这样的形式。若 $oddnum&#x3D;evennum$ ，则既可以是 <code>odd even odd even</code> ，也可以是 <code>even odd even odd</code> 这样的形式。</p>
<p>最后，考虑如何以最小的步骤将数字移动到指定位置。对于数字 $a_i$ ，若其为奇数，则它需要移动的距离为 $i - (2 \times cnto - 1)$ ，其中 $cnto$ 为 $a[1,i]$ 中奇数的个数，$a[1,i]$ 表示序列 $a_1,a_2\cdots a_i$ ，偶数同理。</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;
using db = double;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

const int N = 1e5 + 10;

ll n, a[N];
int res = 0;

void solve()&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
    &#125;
    
    int anso = 0, cnto = 0;
    int anse = 0, cnte = 0;
    for(int i = 1; i &lt;= n; i++)&#123;
        if(a[i] &amp; 1)&#123;
            cnto++;
            anso += abs(i - 2 * cnto + 1);
        &#125;
        else&#123;
            cnte++;
            anse += abs(i - 2 * cnte + 1);
        &#125;
    &#125;
    
    if(abs(cnto - cnte) &gt; 1)&#123;
        cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
        return;
    &#125;
    else&#123;
        if(cnto &gt; cnte)&#123;
            cout &lt;&lt; anso &lt;&lt; &#39;\n&#39;;
        &#125;
        else if(cnte &gt; cnto)&#123;
            cout &lt;&lt; anse &lt;&lt; &#39;\n&#39;;
        &#125;
        else&#123;
            cout &lt;&lt; min(anso, anse) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="J-猴子排班"><a href="#J-猴子排班" class="headerlink" title="J 猴子排班"></a>J 猴子排班</h2><h3 id="题面-9"><a href="#题面-9" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/J.jpeg" alt="J"></p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>经典的约瑟夫环问题。</p>
<p>考虑倒推出：最后剩下的数字，在最开始的数组中的位置。</p>
<p>假设最后一轮的轮次为第 $n$ 轮。</p>
<ol>
<li>第 $n$ 轮时，剩下最后一个数字，总个数为 $1$ ，它的下标为 $pos_n &#x3D; 0$ 。</li>
<li>它在第 $n-1$ 轮中的下标为 $pos_{n-1} &#x3D; (pos_n + m) \mod 2$ ，可以自行画图看出。</li>
<li>同理，它在第 $n-2$ 中的下标为 $pos_{n-2} &#x3D; (pos_{n-1}+m)\mod 3$ 。</li>
<li>因此，我们发现，假如它在第 $n-i$ 轮中的下标为 $pos_{n-i}$ ，则第 $n-i-1$ 轮中的下标就为 $pos_{n-i-1}&#x3D;(pos_{n-i}+m)\mod (i+2)$ 。</li>
</ol>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;
using db = double;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

int n, m;

void solve()&#123;
    cin &gt;&gt; n &gt;&gt; m;
    
    int pos = 0;
    for(int i = 0; i &lt;= n - 2; i++)&#123;
        //从第n轮开始，到第1轮结束
        pos = (pos + m) % (i + 2);
    &#125;
    cout &lt;&lt; pos + 1 &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h2 id="K-你被赋予了这最后的希望"><a href="#K-你被赋予了这最后的希望" class="headerlink" title="K 你被赋予了这最后的希望"></a>K 你被赋予了这最后的希望</h2><h3 id="题面-10"><a href="#题面-10" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/K.jpeg" alt="K"></p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>首先考虑暴力做法，枚举每一个周期 $k$ ，查看是否满足条件，接下来分析如何 $check$ 。</p>
<p>首先我们记字符串总长度 $n &#x3D; a + b$ 。假设一个周期内 $A$ 的数量为 $x$ ， $B$ 的数量为 $y$ ，其中 $x$ 和 $y$ 满足 $k &#x3D; x + y$ ，循环节的数量为 $p &#x3D; \lfloor \frac{n}{k}\rfloor$ ，那么一定满足 $x·p\le a$ 且 $y·p\le b$ 。同时，剩余的边角料 $A$ 和 $B$ 的数量都应该小于等于循环节中 $A$ 和 $B$ 的数量，因此 $x·(p+1)\ge a$ 且 $y·(p+1)\ge b$ 。</p>
<p>将上述四个不等式合并一下，得到</p>
<p>$$\lceil \frac{a}{p+1}\rceil \le x \le \lfloor \frac{a}{p}\rfloor$$</p>
<p>$$\lceil \frac{b}{p+1}\rceil \le y \le \lfloor \frac{b}{p}\rfloor$$</p>
<p>再将上述两个不等式合并一下，得到</p>
<p>$$\lfloor \frac{a+b+p}{p+1}\rfloor \le k \le \lfloor \frac{a+b}{p}\rfloor$$</p>
<p>此时，我们只需要枚举每一个 $p$ 值，就可以得到每一个 $k$ 的取值范围，将所有的 $k$ 所在的区间取并集，就可以得到答案，可以采用数论分块来优化时间复杂度。</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;
using db = double;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
//	cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

int a, b;

void solve()&#123;
    cin &gt;&gt; a &gt;&gt; b;
    
    int n = a + b, res = 0;
    for(int l = 1, r; l &lt;= n; l = r + 1)&#123;
        r = n / (n / l);
        int p = n / l;
        int al = (a + p) / (p + 1), ar = a / p;
        int bl = (b + p) / (p + 1), br = b / p;
        if(al &lt;= ar &amp;&amp; bl &lt;= br)&#123;
            res += max(0, min(r, ar + br) - max(l, al + bl) + 1);
        &#125;
    &#125;
    
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h2 id="L-勇者阿狗"><a href="#L-勇者阿狗" class="headerlink" title="L 勇者阿狗"></a>L 勇者阿狗</h2><h3 id="题面-11"><a href="#题面-11" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/L.jpeg" alt="L"></p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>令一个数字 $x$ 的每位数字和为 $s(x)$ 。</p>
<p>考虑到每个数字 $x$ 都可以通过初始值 $1$ 来进行有限个 $+1$ 或 $\times 10$ 操作构造出来，其中 $+1$ 操作会令该数字 $s(x)$ 加一，那么我们可以通过该构造方式来构造出 $k$ 的倍数。</p>
<p>在 $\mod k$ 的意义下进行计算，把 $0$ ~ $k-1$ 中的每一个数看成一个点， $i$ 向 $i+1$ 连值为 $1$ 的边， $i$ 向 $10·i$ 连一条权值为 $0$ 的边。那么从 $1$ 开始走到 $0$ ，也就是从 $1$ 走到 $k$ 的倍数。那么最小的 $s(x)$ 就是该图中从 $1$ 到 $0$ 的最短路。</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;
using db = double;
using pii = pair&lt;int, int&gt;;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
    cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

const int N = 1e5 + 10, M = 2e6 + 10;

int h[N], e[M], ne[M], w[M], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;

void dijkstra()&#123;
    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;
    dist[1] = 1;
    q.push(&#123;1, 1&#125;);
    while(q.size())&#123;
        int u = q.top().second;
        q.pop();
        if(u == 0) return;
        if(st[u]) continue;
        st[u] = 1;
        for(int i = h[u]; ~i; i = ne[i])&#123;
            int j = e[i];
            if(dist[u] + w[i] &lt; dist[j])&#123;
                dist[j] = dist[u] + w[i];
                q.push(&#123;dist[j], j&#125;);
            &#125;
        &#125;
    &#125; 
&#125;

int k;

void solve()&#123;
    memset(dist, 0x3f, sizeof dist);
    memset(h, -1, sizeof h);
    memset(st, 0, sizeof st);
    idx = 0;
    
    cin &gt;&gt; k;
    if(k == 1) dist[0] = 1;
    for(int i = 1; i &lt; k; i++)&#123;
        add(i, (i + 1) % k, 1);
        add(i, (i * 10) % k, 0);
    &#125;
    
    dijkstra();
    
    cout &lt;&lt; dist[0] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h2 id="M-小楷与小狗"><a href="#M-小楷与小狗" class="headerlink" title="M 小楷与小狗"></a>M 小楷与小狗</h2><h3 id="题面-12"><a href="#题面-12" class="headerlink" title="题面"></a>题面</h3><p><img src="/./../post_source/2021BJFU%E6%96%B0%E7%94%9F%E8%B5%9B/M.jpeg" alt="M"></p>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>对于 $n$ 较小时，直接 $dfs$ 搜索出答案。</p>
<p>对于 $n$ 较大时，可以考虑构造一个序列 $A_n &#x3D; {2^0,2^1,2^2\dots 2^{16}}$ ，这是在数据范围内无法找到任何一组解的数量最大的集合，仅含有 $17$ 个元素，因此当 $n&gt;17$ 时，我们可以只对其中任意 $18$ 个元素跑 $dfs$ ，一定能找到一组解。</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
#define FAST_IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
using namespace std;
using ll = long long;
using db = double;
using pii = pair&lt;int, int&gt;;

void solve();

int main()&#123;
    FAST_IO
    int t = 1;
//	cin &gt;&gt; t;
    while(t--)&#123;
        solve();
    &#125;
&#125;

vector&lt;ll&gt; v;
map&lt;ll, vector&lt;ll&gt;&gt; mp;

int n;

void solve()&#123;
    cin &gt;&gt; n;
    v.resize(n);
    for(ll&amp; e : v)&#123;
        cin &gt;&gt; e;
    &#125;
    
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    
    int sz = min((size_t)18, v.size());
    for(int i = 0; i &lt; (1 &lt;&lt; sz); i++)&#123;
        ll sum = 0;
        vector&lt;ll&gt; res2;
        for(int j = 0; j &lt; sz; j++)&#123;
            if(i &gt;&gt; j &amp; 1)&#123;
                sum += v[j];
                res2.push_back(v[j]);
            &#125;
        &#125;
        if(mp.count(sum))&#123;
            vector&lt;ll&gt; &amp;res1 = mp[sum];
            cout &lt;&lt; res1.size() &lt;&lt; &#39;\n&#39;;
            for(auto e : res1)&#123;
                cout &lt;&lt; e &lt;&lt; &#39; &#39;;
            &#125;
            cout &lt;&lt; &#39;\n&#39;;
            
            cout &lt;&lt; res2.size() &lt;&lt; &#39;\n&#39;;
            for(auto e : res2)&#123;
                cout &lt;&lt; e &lt;&lt; &#39; &#39;;
            &#125;
            cout &lt;&lt; &#39;\n&#39;;
            return;
        &#125;
        else&#123;
            mp[sum] = res2;
        &#125;
    &#125;
    
    cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Yhs_JokerのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Yhs_Joker
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="yhsjoker/yhsjoker.github.io"
    data-repo-id="R_kgDOIchRxw"
    data-category="Announcements"
    data-category-id="DIC_kwDOIchRx84CZAz1"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
