
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>数据结构课设 | Yhs_JokerのBlog</title>
        <meta name="author" content="Yhs_Joker" />
        <meta name="description" content="There is only one kind of heroism in the world, which is to love life after knowing the truth of life." />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YHS_JOKERのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YHS_JOKERのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>数据结构课设</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/11/17
        </span>
        
        <span class="category">
            <a href="/categories/%E4%BD%9C%E4%B8%9A/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                作业
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #00a596">数据结构</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/C/" style="color: #00bcd4">C++</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="第1关：系统函数调用"><a href="#第1关：系统函数调用" class="headerlink" title="第1关：系统函数调用"></a>第1关：系统函数调用</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

using pfunc = void(*)();

#define SUBFUNC_LIST_SIZE (sizeof(subfuncList) / sizeof(pfunc))

bool Jump2Subfunc(pfunc subfuncList[], size_t subfuncNum)&#123;
    char subfuncCh;
    cin &gt;&gt; subfuncCh;
    int subfuncOrder = subfuncCh - &#39;0&#39;;
    if(subfuncOrder &lt; 0 || subfuncOrder &gt;= subfuncNum) return false;
    pfunc subfunc = subfuncList[subfuncOrder];
    if(subfunc == nullptr) return false;
    subfunc();
    return true;
&#125;

// 以下定义的函数可供其他函数调用，以实现本题功能
// 本题的输入需自己设置，可以使用switch case实现调用对应的函数
void InsertFood() &#123;
    cout &lt;&lt; &quot;食材信息增加&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void DeleteFood() &#123;
    cout &lt;&lt; &quot;食材信息删除&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void ModifyFood() &#123;
    cout &lt;&lt; &quot;食材信息修改&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void SeqSearch() &#123;
    cout &lt;&lt; &quot;基于顺序表的顺序查找&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void BinarySearch() &#123;
    cout &lt;&lt; &quot;基于顺序表的折半查找&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void SearchList() &#123;
    cout &lt;&lt; &quot;基于链表的顺序查找&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void SearchBST() &#123;
    cout &lt;&lt; &quot;基于二叉排序树的查找&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void TrieSearch() &#123;
    cout &lt;&lt; &quot;基于字典树的查找&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void SearchHash() &#123;
    cout &lt;&lt; &quot;基于开放地址法的散列查找&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void SearchHL() &#123;
    cout &lt;&lt; &quot;基于链地址法的散列查找&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void KMP() &#123;
    cout &lt;&lt; &quot;基于KMP算法的食材关键信息查询&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void InsertSort() &#123;
    cout &lt;&lt; &quot;直接插入排序&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void BInsertSort() &#123;
    cout &lt;&lt; &quot;折半插入排序&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void SelectSort() &#123;
    cout &lt;&lt; &quot;简单选择排序&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void BubbleSort() &#123;
    cout &lt;&lt; &quot;冒泡排序&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void QuickSort() &#123;
    cout &lt;&lt; &quot;快速排序&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;
    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void MSDSort() &#123;
    cout &lt;&lt; &quot;高位优先字符串排序&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void EntityRecognition() &#123;
    cout &lt;&lt; &quot;基于规则的实体识别&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void RelationExtraction() &#123;
    cout &lt;&lt; &quot;基于规则的关系抽取&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void CreateUDG() &#123;
    cout &lt;&lt; &quot;基于邻接表的知识图谱构建&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void QuestionAnswering() &#123;
    cout &lt;&lt; &quot;基于路径推理的知识图谱多跳问答&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void CreateAMG() &#123;
    cout &lt;&lt; &quot;基于编辑距离的食材功效矩阵构建&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void ShortestPathDIJ() &#123;
    cout &lt;&lt; &quot;基于Dijkstra算法的食材推荐&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void ShortestPathFloyd() &#123;
    cout &lt;&lt; &quot;基于Floyd算法的食材推荐&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void FoodADM() &#123;
// 食材基本信息的增加、删除与修改模块，调用对应的功能函数实现
    cout &lt;&lt; &quot;食材基本信息的增加、删除与修改&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr, InsertFood, DeleteFood, ModifyFood
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void FoodSearch() &#123;
// 基于多种查找策略的食材信息查找模块，调用对应的功能函数实现
    cout &lt;&lt; &quot;基于多种查找策略的食材信息查找&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr, SeqSearch, BinarySearch, SearchList, SearchBST, TrieSearch, SearchHash, SearchHL
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void FoodSort() &#123;
// 基于多种排序策略的食材信息排序模块，调用对应的功能函数实现
    cout &lt;&lt; &quot;基于多种排序策略的食材信息排序&quot; &lt;&lt; endl;

    static pfunc subfuncList[] = &#123;
        nullptr, InsertSort, BInsertSort, SelectSort, BubbleSort, QuickSort, MSDSort
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void FoodManagement() &#123;
// 食材基本信息管理模块
// 调用FoodADM()、FoodSearch()、KMP()、FoodSort()函数实现
    cout &lt;&lt; &quot;食材基本信息管理&quot; &lt;&lt; endl;
    
    static pfunc subfuncList[] = &#123;
        nullptr, FoodADM, FoodSearch, KMP, FoodSort
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void CreateKG() &#123;
// 中医食疗知识图谱构建模块，调用对应的功能函数实现
    cout &lt;&lt; &quot;中医食疗知识图谱构建&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr, EntityRecognition, RelationExtraction, CreateUDG
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void QAAndRecommendation() &#123;
// 中医食疗问答与推荐模块，调用对应的功能函数实现
    cout &lt;&lt; &quot;中医食疗问答与推荐&quot; &lt;&lt; endl;
    static pfunc subfuncList[] = &#123;
        nullptr, QuestionAnswering, CreateAMG, ShortestPathDIJ, ShortestPathFloyd
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));
&#125;

void SystemCall() &#123;
// 基于知识图谱的中医食疗数据管理与应用系统功能调用
// 调用FoodManagement()、CreateKG()、QAAndRecommendation()函数实现
    static pfunc subfuncList[] = &#123;
        nullptr, FoodManagement, CreateKG, QAAndRecommendation
    &#125;;
    const size_t subfuncNum = SUBFUNC_LIST_SIZE;

    while(Jump2Subfunc(subfuncList, subfuncNum));

    cout &lt;&lt; &quot;退出系统&quot; &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="第2关：食材信息增加"><a href="#第2关：食材信息增加" class="headerlink" title="第2关：食材信息增加"></a>第2关：食材信息增加</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000

using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;



void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;

    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder + 1;

    ifs.close();
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    os &lt;&lt; recipeKey &lt;&lt; endl;
    for(int i = 0; i &lt; food.recipe_size; i++)&#123;
        os &lt;&lt; food.recipe[i] &lt;&lt; endl;
    &#125;
    os &lt;&lt; therapyKey &lt;&lt; endl;
    for(int i = 0; i &lt; food.therapy_size; i++)&#123;
        os &lt;&lt; food.therapy[i] &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;

void SaveFile(SqList &amp;L, string filename)&#123;
    // 保存食材信息到文件
    ofstream ofs(filename);
    if(!ofs.is_open())&#123;
        return;
    &#125;

    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        PrintFood(ofs, food);
        if(i != L.length - 1)&#123;
            ofs &lt;&lt; &#39;#&#39; &lt;&lt; endl;
        &#125;
    &#125;
    
    ofs.close();
&#125;

int FindFood(SqList &amp;L, const char *foodName)&#123;
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        
        if(strcmp(food.name, foodName) == 0)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;

bool InsertFood(SqList &amp;L)&#123;
    // 插入食材信息，输入食材中文名称、英文名称、养生功效、营养与功效、养生保健食谱和食疗验方信息
    // 如果插入成功，返回true，否则，返回false
    Food food;
    string info;
    
    getline(cin, info);
    strcpy(food.name, info.c_str());
    
    getline(cin, info);
    strcpy(food.sname, info.c_str());
    
    getline(cin, info);
    strcpy(food.health, info.c_str());
    
    getline(cin, info);
    strcpy(food.nutrition, info.c_str());
    
    getline(cin, info);
    strcpy(food.expert, info.c_str());
    
    getline(cin, info);
    strcpy(food.link, info.c_str());
    
    getline(cin, info);
    food.recipe_size = 0;
    int rec_sz = stoi(info);
    for(int i = 1; i &lt;= rec_sz; i++)&#123;
        getline(cin, info);
        food.recipe[food.recipe_size++] = info;
    &#125;
    
    getline(cin, info);
    food.therapy_size = 0;
    int the_sz = stoi(info);
    for(int i = 1; i &lt;= the_sz; i++)&#123;
        getline(cin, info);
        food.therapy[food.therapy_size++] = info;
    &#125;
    
    if(FindFood(L, food.name) != -1)&#123;
        return false;
    &#125;
    
    FoodCpy(L.elem[L.length++], food);
    return true;
&#125;

void Print(SqList &amp;L)&#123;
    // 输出食材信息
    if(L.length == 0) return;
    Food &amp;food = L.elem[L.length - 1];
    PrintFood(cout, food);
&#125;
</code></pre>
<h2 id="第3关：食材信息删除"><a href="#第3关：食材信息删除" class="headerlink" title="第3关：食材信息删除"></a>第3关：食材信息删除</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000

using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;

    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder + 1;
    
    ifs.close();
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    os &lt;&lt; recipeKey &lt;&lt; endl;
    for(int i = 0; i &lt; food.recipe_size; i++)&#123;
        os &lt;&lt; food.recipe[i] &lt;&lt; endl;
    &#125;
    os &lt;&lt; therapyKey &lt;&lt; endl;
    for(int i = 0; i &lt; food.therapy_size; i++)&#123;
        os &lt;&lt; food.therapy[i] &lt;&lt; endl;
    &#125;
&#125;

void SaveFile(SqList &amp;L, string filename)&#123;
    // 保存食材信息到文件
    ofstream ofs(filename);
    if(!ofs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        PrintFood(ofs, food);
        if(i != L.length - 1)&#123;
            ofs &lt;&lt; &#39;#&#39; &lt;&lt; endl;
        &#125;
    &#125;
    
    ofs.close();
&#125;

int FindFood(SqList &amp;L, const char *foodName)&#123;
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        
        if(strcmp(food.name, foodName) == 0)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

bool InsertFood(SqList &amp;L)&#123;
    // 插入食材信息，输入食材中文名称、英文名称、养生功效、营养与功效、养生保健食谱和食疗验方信息
    // 如果插入成功，返回true，否则，返回false
    Food food;
    string info;
    
    getline(cin, info);
    strcpy(food.name, info.c_str());
    
    getline(cin, info);
    strcpy(food.sname, info.c_str());
    
    getline(cin, info);
    strcpy(food.health, info.c_str());
    
    getline(cin, info);
    strcpy(food.nutrition, info.c_str());
    
    getline(cin, info);
    strcpy(food.expert, info.c_str());
    
    getline(cin, info);
    strcpy(food.link, info.c_str());
    
    getline(cin, info);
    food.recipe_size = 0;
    int rec_sz = stoi(info);
    for(int i = 1; i &lt;= rec_sz; i++)&#123;
        getline(cin, info);
        food.recipe[food.recipe_size++] = info;
    &#125;
    
    getline(cin, info);
    food.therapy_size = 0;
    int the_sz = stoi(info);
    for(int i = 1; i &lt;= the_sz; i++)&#123;
        getline(cin, info);
        food.therapy[food.therapy_size++] = info;
    &#125;
    
    if(FindFood(L, food.name) != -1)&#123;
        return false;
    &#125;
    
    L.elem[L.length++] = food;
    return true;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;

Food *DeleteFood(SqList &amp;L, char *name)&#123;
    // 根据中文名称删除指定食材信息
    // 如果删除成功，返回该食材的信息，否则，返回NULL
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return nullptr;
    
    Food *food = new Food;
    FoodCpy(*food, L.elem[foodPos]);
    
    for(int i = foodPos; i &lt; L.length - 1; i++)&#123;
        FoodCpy(L.elem[i], L.elem[i + 1]);
    &#125;
    L.length--;
    
    return food;
&#125;

void Print(Food *food)&#123;
    // 输出食材信息
    PrintFood(cout, *food);
&#125;
</code></pre>
<h2 id="第4关：食材信息修改"><a href="#第4关：食材信息修改" class="headerlink" title="第4关：食材信息修改"></a>第4关：食材信息修改</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000

using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder + 1;
    
    ifs.close();
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    os &lt;&lt; recipeKey &lt;&lt; endl;
    for(int i = 0; i &lt; food.recipe_size; i++)&#123;
        os &lt;&lt; food.recipe[i] &lt;&lt; endl;
    &#125;
    os &lt;&lt; therapyKey &lt;&lt; endl;
    for(int i = 0; i &lt; food.therapy_size; i++)&#123;
        os &lt;&lt; food.therapy[i] &lt;&lt; endl;
    &#125;
&#125;

void SaveFile(SqList &amp;L, string filename)&#123;
    // 保存食材信息到文件
    ofstream ofs(filename);
    if(!ofs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        PrintFood(ofs, food);
        if(i != L.length - 1)&#123;
            ofs &lt;&lt; &#39;#&#39; &lt;&lt; endl;
        &#125;
    &#125;
    
    ofs.close();
&#125;

int FindFood(SqList &amp;L, const char *foodName)&#123;
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        
        if(strcmp(food.name, foodName) == 0)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

bool InsertFood(SqList &amp;L)&#123;
    // 插入食材信息，输入食材中文名称、英文名称、养生功效、营养与功效、养生保健食谱和食疗验方信息
    // 如果插入成功，返回true，否则，返回false
    Food food;
    string info;
    
    getline(cin, info);
    strcpy(food.name, info.c_str());
    
    getline(cin, info);
    strcpy(food.sname, info.c_str());
    
    getline(cin, info);
    strcpy(food.health, info.c_str());
    
    getline(cin, info);
    strcpy(food.nutrition, info.c_str());
    
    getline(cin, info);
    strcpy(food.expert, info.c_str());
    
    getline(cin, info);
    strcpy(food.link, info.c_str());
    
    getline(cin, info);
    food.recipe_size = 0;
    int rec_sz = stoi(info);
    for(int i = 1; i &lt;= rec_sz; i++)&#123;
        getline(cin, info);
        food.recipe[food.recipe_size++] = info;
    &#125;
    
    getline(cin, info);
    food.therapy_size = 0;
    int the_sz = stoi(info);
    for(int i = 1; i &lt;= the_sz; i++)&#123;
        getline(cin, info);
        food.therapy[food.therapy_size++] = info;
    &#125;
    
    if(FindFood(L, food.name) != -1)&#123;
        return false;
    &#125;
    
    L.elem[L.length++] = food;
    return true;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;

Food *DeleteFood(SqList &amp;L, char *name)&#123;
    // 根据中文名称删除指定食材信息
    // 如果删除成功，返回该食材的信息，否则，返回NULL
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return nullptr;
    
    Food *food = new Food;
    FoodCpy(*food, L.elem[foodPos]);
    
    for(int i = foodPos; i &lt; L.length - 1; i++)&#123;
        FoodCpy(L.elem[i], L.elem[i + 1]);
    &#125;
    L.length--;
    
    return food;
&#125;

void Print(Food *food)&#123;
    // 输出食材信息
    PrintFood(cout, *food);
&#125;

bool ModifyFood(SqList &amp;L, int type, char *name, string lines[], int n)&#123;
    // 食材信息修改，如果type是0，则修改养生保健食谱，否则修改食疗验方信息
    // 如果修改成功，返回true，否则，返回false
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return false;
    
    Food &amp;food = L.elem[foodPos];
    
    if(type == 0)&#123;
        food.recipe_size = n;
        for(int i = 0; i &lt; n; i++)&#123;
            food.recipe[i] = lines[i];
        &#125;
    &#125;
    else&#123;
        food.therapy_size = n;
        for(int i = 0; i &lt; n; i++)&#123;
            food.therapy[i] = lines[i];
        &#125;
    &#125;
    
    return true;
&#125;

Food *getFood(SqList &amp;L, char *name)&#123;
    // 获取修改后的食材信息
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return nullptr;
    
    return &amp;L.elem[foodPos];
&#125;
</code></pre>
<h2 id="第5关：基于顺序表的顺序查找"><a href="#第5关：基于顺序表的顺序查找" class="headerlink" title="第5关：基于顺序表的顺序查找"></a>第5关：基于顺序表的顺序查找</h2><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000

using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder + 1;
    
    ifs.close();
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    if(food.recipe_size)&#123;
        os &lt;&lt; recipeKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.recipe_size; i++)&#123;
            os &lt;&lt; food.recipe[i] &lt;&lt; endl;
        &#125;
    &#125;
    if(food.therapy_size)&#123;
        os &lt;&lt; therapyKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.therapy_size; i++)&#123;
            os &lt;&lt; food.therapy[i] &lt;&lt; endl;
        &#125;
    &#125;
&#125;

void SaveFile(SqList &amp;L, string filename)&#123;
    // 保存食材信息到文件
    ofstream ofs(filename);
    if(!ofs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        PrintFood(ofs, food);
        if(i != L.length - 1)&#123;
            ofs &lt;&lt; &#39;#&#39; &lt;&lt; endl;
        &#125;
    &#125;
    
    ofs.close();
&#125;

int FindFood(SqList &amp;L, const char *foodName)&#123;
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        
        if(strcmp(food.name, foodName) == 0)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

bool InsertFood(SqList &amp;L)&#123;
    // 插入食材信息，输入食材中文名称、英文名称、养生功效、营养与功效、养生保健食谱和食疗验方信息
    // 如果插入成功，返回true，否则，返回false
    Food food;
    string info;
    
    getline(cin, info);
    strcpy(food.name, info.c_str());
    
    getline(cin, info);
    strcpy(food.sname, info.c_str());
    
    getline(cin, info);
    strcpy(food.health, info.c_str());
    
    getline(cin, info);
    strcpy(food.nutrition, info.c_str());
    
    getline(cin, info);
    strcpy(food.expert, info.c_str());
    
    getline(cin, info);
    strcpy(food.link, info.c_str());
    
    getline(cin, info);
    food.recipe_size = 0;
    int rec_sz = stoi(info);
    for(int i = 1; i &lt;= rec_sz; i++)&#123;
        getline(cin, info);
        food.recipe[food.recipe_size++] = info;
    &#125;
    
    getline(cin, info);
    food.therapy_size = 0;
    int the_sz = stoi(info);
    for(int i = 1; i &lt;= the_sz; i++)&#123;
        getline(cin, info);
        food.therapy[food.therapy_size++] = info;
    &#125;
    
    if(FindFood(L, food.name) != -1)&#123;
        return false;
    &#125;
    
    L.elem[L.length++] = food;
    return true;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;

Food *DeleteFood(SqList &amp;L, char *name)&#123;
    // 根据中文名称删除指定食材信息
    // 如果删除成功，返回该食材的信息，否则，返回NULL
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return nullptr;
    
    Food *food = new Food;
    FoodCpy(*food, L.elem[foodPos]);
    
    for(int i = foodPos; i &lt; L.length - 1; i++)&#123;
        FoodCpy(L.elem[i], L.elem[i + 1]);
    &#125;
    L.length--;
    
    return food;
&#125;

void Print(SqList &amp;L, int pos)&#123;
// 输出食材信息
    PrintFood(cout, L.elem[pos]);
&#125;

bool ModifyFood(SqList &amp;L, int type, char *name, string lines[], int n)&#123;
    // 食材信息修改，如果type是0，则修改养生保健食谱，否则修改食疗验方信息
    // 如果修改成功，返回true，否则，返回false
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return false;
    
    Food &amp;food = L.elem[foodPos];
    
    if(type == 0)&#123;
        food.recipe_size = n;
        for(int i = 0; i &lt; n; i++)&#123;
            food.recipe[i] = lines[i];
        &#125;
    &#125;
    else&#123;
        food.therapy_size = n;
        for(int i = 0; i &lt; n; i++)&#123;
            food.therapy[i] = lines[i];
        &#125;
    &#125;
    
    return true;
&#125;

Food *getFood(SqList &amp;L, char *name)&#123;
    // 获取修改后的食材信息
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return nullptr;
    
    return &amp;L.elem[foodPos];
&#125;

int SeqSearch(SqList &amp;L, char *sname)&#123;
    // 在顺序表L中顺序查找食材英文名称等于sname的数据元素
    // 若找到，则返回该元素在表中的下标，否则返回-1
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        
        if(strcmp(food.sname, sname) == 0)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

double GetASL(SqList &amp;L)&#123;
    // 返回基于顺序表的顺序查找的ASL
    int len = L.length;
    return (len + 1) / 2.0;
&#125;
</code></pre>
<h2 id="第6关：基于顺序表的折半查找"><a href="#第6关：基于顺序表的折半查找" class="headerlink" title="第6关：基于顺序表的折半查找"></a>第6关：基于顺序表的折半查找</h2><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000

using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder + 1;
    
    ifs.close();
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    if(food.recipe_size)&#123;
        os &lt;&lt; recipeKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.recipe_size; i++)&#123;
            os &lt;&lt; food.recipe[i] &lt;&lt; endl;
        &#125;
    &#125;
    if(food.therapy_size)&#123;
        os &lt;&lt; therapyKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.therapy_size; i++)&#123;
            os &lt;&lt; food.therapy[i] &lt;&lt; endl;
        &#125;
    &#125;
&#125;

void SaveFile(SqList &amp;L, string filename)&#123;
    // 保存食材信息到文件
    ofstream ofs(filename);
    if(!ofs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        PrintFood(ofs, food);
        if(i != L.length - 1)&#123;
            ofs &lt;&lt; &#39;#&#39; &lt;&lt; endl;
        &#125;
    &#125;
    
    ofs.close();
&#125;

int FindFood(SqList &amp;L, const char *foodName)&#123;
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        
        if(strcmp(food.name, foodName) == 0)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

bool InsertFood(SqList &amp;L)&#123;
    // 插入食材信息，输入食材中文名称、英文名称、养生功效、营养与功效、养生保健食谱和食疗验方信息
    // 如果插入成功，返回true，否则，返回false
    Food food;
    string info;
    
    getline(cin, info);
    strcpy(food.name, info.c_str());
    
    getline(cin, info);
    strcpy(food.sname, info.c_str());
    
    getline(cin, info);
    strcpy(food.health, info.c_str());
    
    getline(cin, info);
    strcpy(food.nutrition, info.c_str());
    
    getline(cin, info);
    strcpy(food.expert, info.c_str());
    
    getline(cin, info);
    strcpy(food.link, info.c_str());
    
    getline(cin, info);
    food.recipe_size = 0;
    int rec_sz = stoi(info);
    for(int i = 1; i &lt;= rec_sz; i++)&#123;
        getline(cin, info);
        food.recipe[food.recipe_size++] = info;
    &#125;
    
    getline(cin, info);
    food.therapy_size = 0;
    int the_sz = stoi(info);
    for(int i = 1; i &lt;= the_sz; i++)&#123;
        getline(cin, info);
        food.therapy[food.therapy_size++] = info;
    &#125;
    
    if(FindFood(L, food.name) != -1)&#123;
        return false;
    &#125;
    
    L.elem[L.length++] = food;
    return true;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;

Food *DeleteFood(SqList &amp;L, char *name)&#123;
    // 根据中文名称删除指定食材信息
    // 如果删除成功，返回该食材的信息，否则，返回NULL
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return nullptr;
    
    Food *food = new Food;
    FoodCpy(*food, L.elem[foodPos]);
    
    for(int i = foodPos; i &lt; L.length - 1; i++)&#123;
        FoodCpy(L.elem[i], L.elem[i + 1]);
    &#125;
    L.length--;
    
    return food;
&#125;

void Print(Food *food)&#123;
    // 输出食材信息
    PrintFood(cout, *food);
&#125;

void Print(SqList &amp;L, int pos)&#123;
    //输出食材信息
    PrintFood(cout, L.elem[pos]);
&#125;

bool ModifyFood(SqList &amp;L, int type, char *name, string lines[], int n)&#123;
    // 食材信息修改，如果type是0，则修改养生保健食谱，否则修改食疗验方信息
    // 如果修改成功，返回true，否则，返回false
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return false;
    
    Food &amp;food = L.elem[foodPos];
    
    if(type == 0)&#123;
        food.recipe_size = n;
        for(int i = 0; i &lt; n; i++)&#123;
            food.recipe[i] = lines[i];
        &#125;
    &#125;
    else&#123;
        food.therapy_size = n;
        for(int i = 0; i &lt; n; i++)&#123;
            food.therapy[i] = lines[i];
        &#125;
    &#125;
    
    return true;
&#125;

Food *getFood(SqList &amp;L, char *name)&#123;
    // 获取修改后的食材信息
    int foodPos = FindFood(L, name);
    if(foodPos == -1) return nullptr;
    
    return &amp;L.elem[foodPos];
&#125;

int SeqSearch(SqList &amp;L, char *sname)&#123;
    // 在顺序表L中顺序查找食材英文名称等于sname的数据元素
    // 若找到，则返回该元素在表中的下标，否则返回-1
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        
        if(strcmp(food.sname, sname) == 0)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

void SortFood(SqList &amp;L)&#123;
    // 从小到大排序
    for(int i = L.length - 1; i &gt;= 0; i--)&#123;
        for(int j = 0; j &lt; i; j++)&#123;
            Food &amp;lhs = L.elem[j], &amp;rhs = L.elem[j + 1];
            if(strcmp(lhs.sname, rhs.sname) &gt; 0)&#123;
                swap(lhs, rhs);
            &#125;
        &#125;
    &#125;
&#125;

int BinarySearch(SqList &amp;L, char *sname)&#123;
    // 在顺序表L中折半查找食材英文名称等于sname的数据元素
    // 若找到，则返回该元素在表中的下标，否则返回-1
    int lft = 0, rgt = L.length - 1;
    while(lft &lt;= rgt)&#123;
        int mid = lft + rgt &gt;&gt; 1;
        int cmp = strcmp(sname, L.elem[mid].sname);
        if(cmp &lt; 0)&#123;
            rgt = mid - 1;
        &#125;
        else if(cmp &gt; 0)&#123;
            lft = mid + 1;
        &#125;
        else&#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;

int build(int l, int r, int dep)&#123;
    if(l &gt; r) return 0;
    int mid = l + r &gt;&gt; 1;
    return dep + build(l, mid - 1, dep + 1) + build(mid + 1, r, dep + 1);
&#125;

double GetASL(SqList &amp;L)&#123;
    // 返回基于顺序表的折半查找的ASL
    int n = L.length;
    return build(1, n, 1) / (double)n;
&#125;
</code></pre>
<h2 id="第7关：基于链表的顺序查找"><a href="#第7关：基于链表的顺序查找" class="headerlink" title="第7关：基于链表的顺序查找"></a>第7关：基于链表的顺序查找</h2><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct LNode&#123;
    Food data;			        // 食材信息
    struct LNode *next;         // 指向下一级结点
&#125; LNode, *LinkList;

void InitList(LinkList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L = new LNode;
    L -&gt; next = nullptr;
&#125;

void FreeList(LinkList &amp;L)&#123;
    // 释放内存
    while(L -&gt; next)&#123;
        LinkList p = L -&gt; next;
        L -&gt; next = p -&gt; next;
        delete p;
    &#125;
    delete L;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(LinkList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入链表中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    string info;
    L -&gt; next = new LNode;
    LinkList p = L -&gt; next;
    p -&gt; next = nullptr;
    
    
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = p -&gt; data;
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            p -&gt; next = new LNode;
            p = p -&gt; next;
            p -&gt; next = nullptr;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    ifs.close();
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    if(food.recipe_size)&#123;
        os &lt;&lt; recipeKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.recipe_size; i++)&#123;
            os &lt;&lt; food.recipe[i] &lt;&lt; endl;
        &#125;
    &#125;
    if(food.therapy_size)&#123;
        os &lt;&lt; therapyKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.therapy_size; i++)&#123;
            os &lt;&lt; food.therapy[i] &lt;&lt; endl;
        &#125;
    &#125;
&#125;


void Print(LNode *p)&#123;
    // 输出食材信息
    PrintFood(cout, p -&gt; data);
&#125;

LNode *SearchList(LinkList &amp;L, char *sname)&#123;
    // 在带头结点的单链表L中查找食材英文名称为sname的元素
    for(LinkList p = L -&gt; next; p; p = p -&gt; next)&#123;
        Food &amp;food = p -&gt; data;
        
        if(strcmp(food.sname, sname) == 0)&#123;
            return p;
        &#125;
    &#125;
    return nullptr;
&#125;

size_t GetListSize(LinkList &amp;L)&#123;
    if(!L) return 0;
    return GetListSize(L -&gt; next) + 1;
&#125;

double GetASL(LinkList &amp;L)&#123;
    // 返回基于链表的顺序查找的ASL
    int n = GetListSize(L -&gt; next);
    return (double)(n + 1) / 2;
&#125;
</code></pre>
<h2 id="第8关：基于二叉排序树的查找"><a href="#第8关：基于二叉排序树的查找" class="headerlink" title="第8关：基于二叉排序树的查找"></a>第8关：基于二叉排序树的查找</h2><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct BSTNode&#123;
    Food data;				    // 食材信息
    struct BSTNode *lchild;     // 左孩子指针
    struct BSTNode *rchild;     // 右孩子指针
&#125; BSTNode, *BSTree;

void InitBSTree(BSTree &amp;T)&#123;
    // 二叉排序树初始化
    T = nullptr;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;

void InsertBST(BSTree &amp;T, Food e)&#123; 
    // 当二叉排序树T中不存在关键字等于e.sname的数据元素时，则插入该元素
    if(!T)&#123;
        T = new BSTNode;
        T -&gt; lchild = nullptr;
        T -&gt; rchild = nullptr;
        FoodCpy(T -&gt; data, e);
    &#125;
    else&#123;
        Food food = T -&gt; data;
        int cmp = strcmp(e.sname, food.sname);
        if(cmp &lt; 0)&#123;
            InsertBST(T -&gt; lchild, e);
        &#125;
        else if(cmp &gt; 0)&#123;
            InsertBST(T -&gt; rchild, e);
        &#125;
    &#125;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

int ReadFile(BSTree &amp;T, string filename)&#123;
    // 读取文件，调用InsertBST函数将每个食材数据插入二叉排序树
    // 返回食材的总数
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return 0;
    &#125;
    
    string info;
    Food food;
    bool inRecipe = 0, inTherapy = 0;
    int foodCnt = 0;
    
    
    while(getline(ifs, info))&#123;
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            InsertBST(T, food);
            foodCnt++;
            food.recipe_size = 0, food.therapy_size = 0;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    InsertBST(T, food);
    foodCnt++;
    
    ifs.close();
    return foodCnt;
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    if(food.recipe_size)&#123;
        os &lt;&lt; recipeKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.recipe_size; i++)&#123;
            os &lt;&lt; food.recipe[i] &lt;&lt; endl;
        &#125;
    &#125;
    if(food.therapy_size)&#123;
        os &lt;&lt; therapyKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.therapy_size; i++)&#123;
            os &lt;&lt; food.therapy[i] &lt;&lt; endl;
        &#125;
    &#125;
&#125;

void Print(BSTNode *T)&#123;
    // 输出食材信息
    PrintFood(cout, T -&gt; data);
&#125;

BSTNode *SearchBST(BSTree &amp;T, char *sname)&#123;
    // 查找对应食材
    if(!T) return nullptr;
    Food food = T -&gt; data;
    int cmp = strcmp(sname, food.sname);
    if(cmp &lt; 0)&#123;
        return SearchBST(T -&gt; lchild, sname);
    &#125;
    else if(cmp &gt; 0)&#123;
        return SearchBST(T -&gt; rchild, sname);
    &#125;
    else&#123;
        return T;
    &#125;
&#125;

int GetSumCmp(BSTree T, int sumCmp)&#123;
    // 统计查找成功时的总比较次数
    if(!T) return 0;
    return GetSumCmp(T -&gt; lchild, sumCmp + 1) + GetSumCmp(T -&gt; rchild, sumCmp + 1) + sumCmp;
&#125;

double GetASL(BSTree &amp;T, int count)&#123;
    // 返回基于二叉排序树查找的ASL
    return (double)GetSumCmp(T, 1) / count;
&#125;
</code></pre>
<h2 id="第9关：基于字典树的查找"><a href="#第9关：基于字典树的查找" class="headerlink" title="第9关：基于字典树的查找"></a>第9关：基于字典树的查找</h2><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;
typedef struct TNode&#123;
    // 定义字典树结构体
    Food *foodPtr;		        // 食材指针
    struct TNode *child[53];    // 子结点的指针数组，由26个小写字母，26个大写字母，1个空格组成
&#125; TNode, *TrieTree;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder + 1;
    
    ifs.close();
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    if(food.recipe_size)&#123;
        os &lt;&lt; recipeKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.recipe_size; i++)&#123;
            os &lt;&lt; food.recipe[i] &lt;&lt; endl;
        &#125;
    &#125;
    if(food.therapy_size)&#123;
        os &lt;&lt; therapyKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.therapy_size; i++)&#123;
            os &lt;&lt; food.therapy[i] &lt;&lt; endl;
        &#125;
    &#125;
&#125;


TNode *InitTNode()&#123;
    // 初始化Trie树结点
    TrieTree T = new TNode;
    for(int i = 0; i &lt; 53; i++)&#123;
        T -&gt; child[i] = nullptr;
    &#125;
    return T;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;

int GetChildIdx(char ch)&#123;
    if(isupper(ch)) return ch - &#39;A&#39;;
    if(islower(ch)) return ch - &#39;a&#39; + 26;
    return 52;
&#125;

void InsertFood(TrieTree&amp; T, const Food&amp; food)&#123;
    TrieTree p = T;
    for(int i = 0; food.sname[i]; i++)&#123;
        int childIdx = GetChildIdx(food.sname[i]);
        if(!p -&gt; child[childIdx])&#123;
            p -&gt; child[childIdx] = InitTNode();
        &#125;
        p = p -&gt; child[childIdx];
    &#125;
    p -&gt; foodPtr = new Food;
    FoodCpy(*p -&gt; foodPtr, food);
&#125;

TNode *BuildTree(SqList &amp;L)&#123;
    // 构建基于链式存储的Trie树
    // 构建成功后返回指向根节点的指针
    
    TrieTree T = InitTNode();
    
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        InsertFood(T, food);
    &#125;
    
    return T;
&#125;

Food *TrieSearch(TNode *root, char *sname)&#123;
    // 基于字典树的查找
    // 如果查找成功则返回指向该食材的指针，如果查找失败则返回NULL
    TrieTree p = root;
    for(int i = 0; sname[i]; i++)&#123;
        int childIdx = GetChildIdx(sname[i]);
        if(!p -&gt; child[childIdx])&#123;
            return nullptr;
        &#125;
        p = p -&gt; child[childIdx];
    &#125;
    return p -&gt; foodPtr;
&#125;

void Print(Food *food)&#123;
    // 输出Trie树中指针food指向的结点
    PrintFood(cout, *food);
&#125;

double GetASL(SqList &amp;L)&#123;
    // 计算查找成功时的平均查找长度ASL
    int totLength = 0;
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        totLength += strlen(food.sname);
    &#125;
    return (double)totLength / L.length;
&#125;
</code></pre>
<h2 id="第10关：基于开放地址法的散列查找"><a href="#第10关：基于开放地址法的散列查找" class="headerlink" title="第10关：基于开放地址法的散列查找"></a>第10关：基于开放地址法的散列查找</h2><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define m 200
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒 
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123; 
    // 开放地址法散列表的存储表示
    Food *key;
    int length;
&#125; HashTable;

void InitHT(HashTable &amp;HT)&#123;
    // 散列表初始化
    HT.length = 0;
    HT.key = new Food[m];
    for(int i = 0; i &lt; m; i++)&#123;
        strcpy(HT.key[i].sname, &quot;&quot;);
    &#125;
&#125;

int Hash(char *sname)&#123;
    // 实现散列函数：字符串sname中各字符的下标（从0开始）的平方乘以字符对应的ASCII码值，相加后与199取余
    int sum = 0;
    for (int i = 0; i &lt; strlen(sname); i++)
    &#123;
        sum += ((i) * (i) * int(sname[i]));
    &#125;
    return sum % 199;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;

void HTInsert(HashTable &amp;HT, Food f, int &amp;sumCmp)&#123;
    // 往散列表中插入新的食材f
    // 在插入的过程中统计总的比较次数sumCmp
    int hsh = Hash(f.sname);
    for(int i = hsh; i != (hsh + m - 1) % m; i = (i + 1) % m)&#123;
        sumCmp++;
        Food &amp;food = HT.key[i];
        if(strcmp(food.sname, &quot;&quot;) == 0)&#123;
            FoodCpy(food, f);
            HT.length++;
            return;
        &#125;
    &#125;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    if(food.recipe_size)&#123;
        os &lt;&lt; recipeKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.recipe_size; i++)&#123;
            os &lt;&lt; food.recipe[i] &lt;&lt; endl;
        &#125;
    &#125;
    if(food.therapy_size)&#123;
        os &lt;&lt; therapyKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.therapy_size; i++)&#123;
            os &lt;&lt; food.therapy[i] &lt;&lt; endl;
        &#125;
    &#125;
&#125;

void ReadFile(HashTable &amp;HT, int &amp;sumCmp, string filename)&#123;
    // 读取文件，调用HTInsert函数将每条食材数据插入散列表
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    string info;
    Food food;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            HTInsert(HT, food, sumCmp);
            food.recipe_size = food.therapy_size = 0;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    HTInsert(HT, food, sumCmp);
    
    ifs.close();
&#125;

void Print(HashTable HT, int pos)&#123;
    // 输出食材信息
    PrintFood(cout, HT.key[pos]);
&#125;

int SearchHash(HashTable HT, char *key)&#123;
    // 在散列表HT中查找食材英文名称等于key的元素
    // 若找到，则返回散列表的单元标号，否则返回-1
    int hsh = Hash(key);
    for(int i = hsh; i != (hsh + m - 1) % m; i = (i + 1) % m)&#123;
        Food &amp;food = HT.key[i];
        if(strcmp(food.sname, &quot;&quot;) == 0)&#123;
            return -1;
        &#125;
        if(strcmp(food.sname, key) == 0)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

double GetASL(HashTable HT, int sumCmp)&#123;
    // 返回基于开放地址法的散列查找的ASL
    return (double)sumCmp / HT.length;
&#125;
</code></pre>
<h2 id="第11关：基于链地址法的散列查找"><a href="#第11关：基于链地址法的散列查找" class="headerlink" title="第11关：基于链地址法的散列查找"></a>第11关：基于链地址法的散列查找</h2><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define m 200
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct LNode&#123;
    Food data;			        // 食材信息
    struct LNode *next;         // 指向下一级结点
&#125; LNode, *LinkList;

typedef struct&#123; 
    // 开放地址法散列表的存储表示
    Food *key;
    int length;
&#125; HashTable;

void InitList(LinkList *H)&#123;
    // 链表初始化
    for(int i = 0; i &lt; m; i++)&#123;
        H[i] = new LNode;
        H[i] -&gt; next = nullptr;
    &#125;
&#125;

int Hash(char *sname)&#123;
    // 实现散列函数：字符串sname中各字符的下标（从0开始）的平方乘以字符对应的ASCII码值，相加后与199取余
    int sum = 0;
    for (int i = 0; i &lt; strlen(sname); i++)&#123;
        sum += ((i) * (i) * int(sname[i]));
    &#125;
    return sum % 199;
&#125;

void FoodCpy(Food &amp;dst, const Food &amp;src)&#123;
    strcpy(dst.name, src.name);
    strcpy(dst.sname, src.sname);
    strcpy(dst.health, src.health);
    strcpy(dst.nutrition, src.nutrition);
    strcpy(dst.expert, src.expert);
    strcpy(dst.link, src.link);
    dst.recipe_size = src.recipe_size;
    for(int i = 0; i &lt; src.recipe_size; i++)&#123;
        dst.recipe[i] = src.recipe[i];
    &#125;
    dst.therapy_size = src.therapy_size;
    for(int i = 0; i &lt; src.therapy_size; i++)&#123;
        dst.therapy[i] = src.therapy[i];
    &#125;
&#125;


void ListInsert(LinkList *H, Food f, int &amp;sumCmp)&#123;
    // 往散列表中插入新的食材f
    // 在插入的过程中统计总的比较次数sumCmp
    int hsh = Hash(f.sname);
    LinkList p = H[hsh];
    while(p -&gt; next)&#123;
        Food &amp;food = p -&gt; next -&gt; data;
        sumCmp++;
        if(strcmp(food.sname, f.sname) == 0) return;
        p = p -&gt; next;
    &#125;
    sumCmp++;
    p -&gt; next = new LNode;
    p = p -&gt; next;
    p -&gt; next = nullptr;
    FoodCpy(p -&gt; data, f);
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    if(food.recipe_size)&#123;
        os &lt;&lt; recipeKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.recipe_size; i++)&#123;
            os &lt;&lt; food.recipe[i] &lt;&lt; endl;
        &#125;
    &#125;
    if(food.therapy_size)&#123;
        os &lt;&lt; therapyKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.therapy_size; i++)&#123;
            os &lt;&lt; food.therapy[i] &lt;&lt; endl;
        &#125;
    &#125;
&#125;

int ReadFile(LinkList *H, int &amp;sumCmp, string filename)&#123;
    // 读取文件，调用ListInsert函数将每条食材数据插入散列表
    // 返回食材数据的总数
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return 0;
    &#125;
    
    string info;
    Food food;
    int foodCnt = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            ListInsert(H, food, sumCmp);
            foodCnt++;
            food.recipe_size = food.therapy_size = 0;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    ListInsert(H, food, sumCmp);
    foodCnt++;
    
    ifs.close();
    
    return foodCnt;
&#125;

int SearchHL(LinkList *H, char *key)&#123;
    // 在散列表HT中查找食材英文名称等于key的元素
    // 若找到，则返回散列表的单元标号，否则返回-1
    int hsh = Hash(key);
    for(LinkList p = H[hsh]; p -&gt; next; p = p -&gt; next)&#123;
        Food &amp;food = p -&gt; next -&gt; data;
        if(strcmp(food.sname, key) == 0) return hsh;
    &#125;
    return -1;
&#125;

double GetASL(int sumCmp, int count)&#123;
    // 返回基于链地址法的散列查找的ASL
    return (double)sumCmp / count;
&#125;

void Print(LNode *p, char *sname)&#123;
    // 输出食材信息
    for(; p; p = p -&gt; next)&#123;
        Food &amp;food = p -&gt; data;
        if(strcmp(food.sname, sname) == 0) PrintFood(cout, food);
    &#125;
&#125;
</code></pre>
<h2 id="第12关：基于KMP算法的食材关键信息查询"><a href="#第12关：基于KMP算法的食材关键信息查询" class="headerlink" title="第12关：基于KMP算法的食材关键信息查询"></a>第12关：基于KMP算法的食材关键信息查询</h2><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder + 1;
    
    ifs.close();
&#125;

template&lt;typename T&gt;
void PrintFood(T&amp; os, const Food &amp;food)&#123;
    os &lt;&lt; nameKey &lt;&lt; food.name &lt;&lt; endl;
    os &lt;&lt; snameKey &lt;&lt; food.sname &lt;&lt; endl;
    os &lt;&lt; healthKey &lt;&lt; food.health &lt;&lt; endl;
    os &lt;&lt; nutritionKey &lt;&lt; food.nutrition &lt;&lt; endl;
    os &lt;&lt; expertKey &lt;&lt; food.expert &lt;&lt; endl;
    os &lt;&lt; linkKey &lt;&lt; food.link &lt;&lt; endl;
    if(food.recipe_size)&#123;
        os &lt;&lt; recipeKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.recipe_size; i++)&#123;
            os &lt;&lt; food.recipe[i] &lt;&lt; endl;
        &#125;
    &#125;
    if(food.therapy_size)&#123;
        os &lt;&lt; therapyKey &lt;&lt; endl;
        for(int i = 0; i &lt; food.therapy_size; i++)&#123;
            os &lt;&lt; food.therapy[i] &lt;&lt; endl;
        &#125;
    &#125;
&#125;

void SaveFile(SqList &amp;L, string filename)&#123;
    // 保存食材信息到文件
    ofstream ofs(filename);
    if(!ofs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        PrintFood(ofs, food);
        if(i != L.length - 1)&#123;
            ofs &lt;&lt; &#39;#&#39; &lt;&lt; endl;
        &#125;
    &#125;
    
    ofs.close();
&#125;

void GetNext(const char *T, int next[])&#123;
    // 计算子串T的next数组
    next[0] = -1;
    for(int i = 1, j = -1; T[i]; i++)&#123;
        while(j &gt;= 0 &amp;&amp; T[j + 1] != T[i]) j = next[j];
        if(T[j + 1] == T[i]) j++;
        next[i] = j;
    &#125;
&#125;

bool KMP(const char *S, const char *T, int next[])&#123;
    // 利用模式串T的next数组求子串T在主串S中是否存在
    // 如果查找成功则返回true，如果查找失败则返回false
    for(int i = 1, j = -1; S[i]; i++)&#123;
        while(j &gt;= 0 &amp;&amp; S[i] != T[j + 1]) j = next[j];
        if(S[i] == T[j + 1]) j++;
        if(!T[j + 1]) return true;
    &#125;
    return false;
&#125;

bool SearchList(SqList &amp;L, char *keyword, int next[])&#123;
    // 遍历顺序表食材的养生功效和营养与功效信息，调用KMP算法
    // 如果在食材中查找成功则返回true，如果查找失败则返回false
    bool exist = 0;
    for(int i = 0; i &lt; L.length; i++)&#123;
        Food &amp;food = L.elem[i];
        if(KMP(food.health, keyword, next) || KMP(food.nutrition, keyword, next))&#123;
            exist = 1;
            cout &lt;&lt; food.name &lt;&lt; endl;
        &#125;
    &#125;
    return exist;
&#125;
</code></pre>
<h2 id="第13关：直接插入排序"><a href="#第13关：直接插入排序" class="headerlink" title="第13关：直接插入排序"></a>第13关：直接插入排序</h2><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 1;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder;
    
    ifs.close();
&#125;

void InsertSort(SqList &amp;L, int &amp;kcn, int &amp;rmn)&#123;
    // 对顺序表L做直接插入排序，从后向前顺序比较
    // 注：L.elem[0]用做哨兵单元
    // 输出排序后的食材英文名称、KCN和RMN
    
    for(int i = 2; i &lt;= L.length; i++)&#123;
        kcn++;
        if(strcmp(L.elem[i].sname, L.elem[i - 1].sname) &lt; 0)&#123;
            L.elem[0] = L.elem[i];
            L.elem[i] = L.elem[i - 1];
            rmn += 2;
            int j;
            for(j = i - 2; kcn++, strcmp(L.elem[0].sname, L.elem[j].sname) &lt; 0; j--)&#123;
                L.elem[j + 1] = L.elem[j];
                rmn++;
            &#125;
            L.elem[j + 1] = L.elem[0];
            rmn++;
        &#125;
    &#125;
    
    for(int i = 1; i &lt;= L.length; i++)&#123;
        cout &lt;&lt; L.elem[i].sname &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;总的关键字比较次数KCN为：&quot; &lt;&lt; kcn &lt;&lt; endl;
    cout &lt;&lt; &quot;总的记录移动次数RMN为：&quot; &lt;&lt; rmn &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="第14关：折半插入排序"><a href="#第14关：折半插入排序" class="headerlink" title="第14关：折半插入排序"></a>第14关：折半插入排序</h2><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 1;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder;
    
    ifs.close();
&#125;

void BInsertSort(SqList &amp;L, int &amp;kcn, int &amp;rmn)&#123;
// 对顺序表做折半插入排序
// 注：L.elem[0]用做哨兵单元
// 输出排序后的食材英文名称、KCN和RMN
    for(int i = 2; i &lt;= L.length; i++)&#123;
        L.elem[0] = L.elem[i];
        rmn++;
        int low = 1, high = i - 1;
        while(low &lt;= high)&#123;
            int mid = low + high &gt;&gt; 1;
            if(kcn++, strcmp(L.elem[0].sname, L.elem[mid].sname) &lt; 0) high = mid - 1;
            else low = mid + 1;
        &#125;
        for(int j = i - 1; j &gt;= high + 1; j--) L.elem[j + 1] = L.elem[j], rmn++;
        L.elem[high + 1] = L.elem[0];
        rmn++;
    &#125;


    for(int i = 1; i &lt;= L.length; i++)&#123;
        cout &lt;&lt; L.elem[i].sname &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;总的关键字比较次数KCN为：&quot; &lt;&lt; kcn &lt;&lt; endl;
    cout &lt;&lt; &quot;总的记录移动次数RMN为：&quot; &lt;&lt; rmn &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="第15关：简单选择排序"><a href="#第15关：简单选择排序" class="headerlink" title="第15关：简单选择排序"></a>第15关：简单选择排序</h2><h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 1;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder;
    
    ifs.close();
&#125;

void SelectSort(SqList &amp;L, int &amp;kcn, int &amp;rmn)&#123;
// 对顺序表做简单选择排序
// 注：L.elem[0]用做哨兵单元
// 输出排序后的食材英文名称、KCN和RMN
    for(int i = 1; i &lt; L.length; i++)&#123;
        int k = i;
        for(int j = i + 1; j &lt;= L.length; j++)&#123;
            if(kcn++, strcmp(L.elem[j].sname, L.elem[k].sname) &lt; 0)&#123;
                k = j;
            &#125;
        &#125;
        if(k != i)&#123;
            swap(L.elem[i], L.elem[k]);
            rmn += 3;
        &#125;
    &#125;


    for(int i = 1; i &lt;= L.length; i++)&#123;
        cout &lt;&lt; L.elem[i].sname &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;总的关键字比较次数KCN为：&quot; &lt;&lt; kcn &lt;&lt; endl;
    cout &lt;&lt; &quot;总的记录移动次数RMN为：&quot; &lt;&lt; rmn &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="第16关：冒泡排序"><a href="#第16关：冒泡排序" class="headerlink" title="第16关：冒泡排序"></a>第16关：冒泡排序</h2><h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 1;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder;
    
    ifs.close();
&#125;

void BubbleSort(SqList &amp;L, int &amp;kcn, int &amp;rmn)&#123;
// 对顺序表L做冒泡排序
// 注：elem[0]闲置
// 输出排序后的食材英文名称、KCN和RMN
    int m = L.length - 1;
    int flag = 1;
    while((m &gt; 0) &amp;&amp; (flag == 1))&#123;
        flag = 0;
        for(int j = 1; j &lt;= m; j++)&#123;
            if(kcn++, strcmp(L.elem[j].sname, L.elem[j + 1].sname) &gt; 0)&#123;
                flag = 1;
                swap(L.elem[j], L.elem[j + 1]);
                rmn += 3;
            &#125;
        &#125;
        m--;
    &#125;

    for(int i = 1; i &lt;= L.length; i++)&#123;
        cout &lt;&lt; L.elem[i].sname &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;总的关键字比较次数KCN为：&quot; &lt;&lt; kcn &lt;&lt; endl;
    cout &lt;&lt; &quot;总的记录移动次数RMN为：&quot; &lt;&lt; rmn &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="第17关：快速排序"><a href="#第17关：快速排序" class="headerlink" title="第17关：快速排序"></a>第17关：快速排序</h2><h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];		        // 中文名称
    char sname[100];	        // 英文名称
    char health[10000];	        // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];	        // 专家提醒
    char link[10000];	        // 相关链接
    string recipe[30];	        // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];	        // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125; SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 1;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder;
    
    ifs.close();
&#125;

int Partition(SqList &amp;L, int low, int high, int &amp;kcn, int &amp;rmn)&#123;
// 对顺序表中的子表elem[low..high]进行一趟排序，返回枢轴位置
// 用子表的第一个记录做枢轴记录
// 注：L.elem[0]用来存枢轴记录
    L.elem[0] = L.elem[low], rmn++;
    char pivot[100];
    strcpy(pivot, L.elem[low].sname);
    while(low &lt; high)&#123;
        while(low &lt; high &amp;&amp; (kcn++, strcmp(L.elem[high].sname, pivot) &gt;= 0)) high--;
        L.elem[low] = L.elem[high], rmn++;
        while(low &lt; high &amp;&amp; (kcn++, strcmp(L.elem[low].sname, pivot) &lt;= 0)) low++;
        L.elem[high] = L.elem[low], rmn++;
    &#125;
    L.elem[low] = L.elem[0], rmn++;
    return low;
&#125;

void QSort(SqList &amp;L, int low, int high, int &amp;kcn, int &amp;rmn)&#123;
// 调用前置初值：low=1; high=L.length;
// 对顺序表L中的子序列L.elem[low..high]做快速排序
    if(low &lt; high)&#123;
        int pivotloc = Partition(L, low, high, kcn, rmn);
        QSort(L, low, pivotloc - 1, kcn, rmn);
        QSort(L, pivotloc + 1, high, kcn, rmn);
    &#125;
&#125;

void QuickSort(SqList &amp;L)&#123;
// 对顺序表做快速排序
// 输出排序后的食材英文名称、KCN和RMN
    int kcn = 0, rmn = 0;

    QSort(L, 1, L.length, kcn, rmn);
    for(int i = 1; i &lt;= L.length; i++)&#123;
        cout &lt;&lt; L.elem[i].sname &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;总的关键字比较次数KCN为：&quot; &lt;&lt; kcn &lt;&lt; endl;
    cout &lt;&lt; &quot;总的记录移动次数RMN为：&quot; &lt;&lt; rmn &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="第18关：高位优先字符串排序"><a href="#第18关：高位优先字符串排序" class="headerlink" title="第18关：高位优先字符串排序"></a>第18关：高位优先字符串排序</h2><h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    char name[100];             // 中文名称
    char sname[100];            // 英文名称
    char health[10000];         // 养生功效
    char nutrition[10000];      // 营养与功效
    char expert[10000];         // 专家提醒
    char link[10000];           // 相关链接
    string recipe[30];          // 养生保健食谱
    int recipe_size = 0;        // 食谱数量
    string therapy[30];         // 食疗验方
    int therapy_size = 0;       // 验方数量
&#125; Food;
typedef struct&#123;
    Food *elem;                 // 指向数组的指针
    int length;                 // 数组的长度
&#125;SqList;

void InitList(SqList &amp;L)&#123;
    // 使用动态内存分配new进行初始化
    L.elem = new Food[MAXSIZE];
    L.length = 0;
&#125;

void FreeList(SqList &amp;L)&#123;
    // 释放内存
    delete[] L.elem;
    L.length = 0;
&#125;

const char nameKey[] = &quot;中文名称：&quot;;
const char snameKey[] = &quot;英文名称：&quot;;
const char healthKey[] = &quot;养生功效：&quot;;
const char nutritionKey[] = &quot;营养与功效：&quot;;
const char expertKey[] = &quot;专家提醒：&quot;;
const char linkKey[] = &quot;相关链接：&quot;;
const char recipeKey[] = &quot;养生保健食谱：&quot;;
const char therapyKey[] = &quot;食疗验方：&quot;;

void ReadFile(SqList &amp;L, string filename)&#123;
    // 从文件中读取食材信息，将其按顺序存入L.elem指向的数组中
    ifstream ifs(filename);
    
    if(!ifs.is_open())&#123;
        return;
    &#125;
    
    for(int i = 0; i &lt; MAXSIZE; i++)&#123;
        L.elem[i].recipe_size = L.elem[i].therapy_size = 0;
    &#125;
    
    string info;
    int foodOrder = 0;
    bool inRecipe = 0, inTherapy = 0;
    
    
    while(getline(ifs, info))&#123;
        Food &amp;food = L.elem[foodOrder];
        
        if(info.empty())&#123;
            continue;
        &#125;
        else if(info.front() == &#39;#&#39;)&#123;
            foodOrder++;
        &#125;
        else if(info.find(nameKey) != string::npos)&#123;
            strcpy(food.name, info.c_str() + sizeof(nameKey) - 1);
        &#125;
        else if(info.find(snameKey) != string::npos)&#123;
            strcpy(food.sname, info.c_str() + sizeof(snameKey) - 1);
        &#125;
        else if(info.find(healthKey) != string::npos)&#123;
            strcpy(food.health, info.c_str() + sizeof(healthKey) - 1);
        &#125;
        else if(info.find(nutritionKey) != string::npos)&#123;
            strcpy(food.nutrition, info.c_str() + sizeof(nutritionKey) - 1);
        &#125;
        else if(info.find(expertKey) != string::npos)&#123;
            strcpy(food.expert, info.c_str() + sizeof(expertKey) - 1);
        &#125;
        else if(info.find(linkKey) != string::npos)&#123;
            strcpy(food.link, info.c_str() + sizeof(linkKey) - 1);
        &#125;
        else if(info.find(recipeKey) != string::npos)&#123;
            inRecipe = 1, inTherapy = 0;
            continue;
        &#125;
        else if(info.find(therapyKey) != string::npos)&#123;
            inTherapy = 1, inRecipe = 0;
            continue;
        &#125;
        else if(inRecipe)&#123;
            food.recipe[food.recipe_size++] = info;
            continue;
        &#125;
        else if(inTherapy)&#123;
            food.therapy[food.therapy_size++] = info;
            continue;
        &#125;
        inRecipe = inTherapy = 0;
    &#125;
    
    L.length = foodOrder + 1;
    
    ifs.close();
&#125;

const int MX_ASCII = 256;

int ToIdx(SqList &amp;L, int i, int d)&#123;
    int length = strlen(L.elem[i].sname);
    if(d &gt; length) return -1;
    return L.elem[i].sname[d];
&#125;

void MSDSort(SqList &amp;L, SqList &amp;L2, int l, int r, int d)&#123;
//L为原始的顺序表，L2为辅助排序开辟的顺序表，l是排序的下界，r是排序的上界
//d为排序的字母的下标位置，从sname中下标为0的位置开始，往后递归处理
    if(l &gt;= r) return;
    int *count = new int[MX_ASCII + 2];
    memset(count, 0, sizeof(int) * (MX_ASCII + 2));
    for(int i = l; i &lt;= r; i++)&#123;
        count[ToIdx(L, i, d) + 2]++;
    &#125;
    for(int i = 0; i &lt; MX_ASCII + 1; i++)&#123;
        count[i + 1] += count[i];
    &#125;
    for(int i = l; i &lt;= r; i++)&#123;
        L2.elem[count[ToIdx(L, i, d) + 1]++] = L.elem[i];
    &#125;
    for(int i = l; i &lt;= r; i++)&#123;
        L.elem[i] = L2.elem[i - l];
    &#125;
    for(int i = 0; i &lt; MX_ASCII; i++)&#123;
        MSDSort(L, L2, l + count[i], l + count[i + 1] - 1, d + 1);
    &#125;
    delete[] count;
&#125;
</code></pre>
<h2 id="第19关：基于规则的实体识别"><a href="#第19关：基于规则的实体识别" class="headerlink" title="第19关：基于规则的实体识别"></a>第19关：基于规则的实体识别</h2><h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;

bool EntityRecognition(const char *S, const char *T)&#123;
// S为非结构化文本，T为规则
// 如果匹配成功返回true，否则返回false
// 输出所有匹配到的实体
    bool match_succeed = 0;
    for(int i = 0; S[i]; i++)&#123;
        bool isMatch = 0;
        for(int p = i, q = 0; ; p++, q++)&#123;
            if(!T[q])&#123;
                isMatch = 1;
                break;
            &#125;
            if(T[q] == &#39;*&#39;)&#123;
                if(S[p] &amp; (1 &lt;&lt; 7)) p += 2;
                continue;
            &#125;
            if(S[p] != T[q]) break;
        &#125;
        if(isMatch)&#123;
            match_succeed = 1;
            for(int p = i, q = 0; T[q]; p++, q++)&#123;
                if(T[q] == &#39;*&#39;)&#123;
                    if(S[p] &amp; (1 &lt;&lt; 7))&#123;
                        cout &lt;&lt; S[p] &lt;&lt; S[p + 1] &lt;&lt; S[p + 2];
                        p += 2;
                    &#125;
                    else&#123;
                        cout &lt;&lt; S[p];
                    &#125;
                &#125;
            &#125;
            cout &lt;&lt; endl;
        &#125;
    &#125;
    return match_succeed;
&#125;
</code></pre>
<h2 id="第20关：基于规则的关系抽取"><a href="#第20关：基于规则的关系抽取" class="headerlink" title="第20关：基于规则的关系抽取"></a>第20关：基于规则的关系抽取</h2><h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MAXSIZE 10000
using namespace std;
typedef struct&#123;
    string relation;    //关系名称
    string rule[10];    //规则数组
&#125; Relation;

bool TransPattern(char *A, char *B, string rule, char *pattern)&#123;
    pattern[0] = 0;
    for(char c : rule)&#123;
        if(c == &#39;A&#39;)&#123;
            strcat(pattern, A);
        &#125;
        else if(c == &#39;B&#39;)&#123;
            strcat(pattern, B);
        &#125;
        else&#123;
            strncat(pattern, &amp;c, 1);
        &#125;
    &#125;
&#125;

bool Match(char *text, char *pattern)&#123;
    for(int i = 0; text[i]; i++)&#123;
        for(int p = i, q = 0; ; p++, q++)&#123;
            if(!pattern[q])&#123;
                return true;
            &#125;
            if(text[p] != pattern[q]) break;
        &#125;
    &#125;
    return false;
&#125;

bool RelationExtraction(char *text, char *entity1, char *entity2, Relation *r)&#123;
// 如果实体之间存在关系返回true，否则返回false
// 输出所有存在的三元组
    char *pattern = new char[1000];
    bool match_succeed = 0;
    for(int i = 0; r[i].relation.size(); i++)&#123;
        for(int j = 0; r[i].rule[j].size(); j++)&#123;
            TransPattern(entity1, entity2, r[i].rule[j], pattern);
            if(Match(text, pattern))&#123;
                match_succeed = 1;
                cout &lt;&lt; entity1 &lt;&lt; &#39;-&#39; &lt;&lt; r[i].relation &lt;&lt; &#39;-&#39; &lt;&lt; entity2 &lt;&lt; endl;
            &#125;
        &#125;
    &#125;
    delete[] pattern;
    return match_succeed;
&#125;
</code></pre>
<h2 id="第21关：基于邻接表的知识图谱构建"><a href="#第21关：基于邻接表的知识图谱构建" class="headerlink" title="第21关：基于邻接表的知识图谱构建"></a>第21关：基于邻接表的知识图谱构建</h2><h3 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MVNum 10000
using namespace std;

string Relationship[] = &#123;&quot;有功效&quot;,&quot;有食谱&quot;,&quot;有推荐食材&quot;,&quot;有证机概要&quot;&#125;;
typedef struct ArcNode &#123;
    int adjvex;                     // 该边所指向顶点的位置
    int relationship;               // 表示边的类型，即关系的类型，对应为数组下标 
    struct ArcNode* nextarc;        // 下一条边
&#125; ArcNode;                          // 边结点

string Entity[]= &#123;&quot;食材&quot;,&quot;疾病&quot;,&quot;功效&quot;,&quot;食谱&quot;,&quot;证机概要&quot;&#125;;
typedef struct VNode &#123;
    int entity;                     // 表示顶点的类型，即实体的类型，对应为数组下标
    string info;                    // 表示顶点的内容，即实体的内容
    ArcNode* firstarc;              // 指向第一条依附该顶点的边的指针
&#125; VNode, AdjList[MVNum];

typedef struct &#123;
    AdjList vertices;               // 邻接表
    int vexnum, arcnum;             // 图的当前顶点数和边数
&#125; ALGraph;

int LocateVex(ALGraph&amp; G, string str) &#123;
// 返回str在AdjList中的位置
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        if(G.vertices[i].info == str)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateEntity(string str) &#123;
// 返回str在Entity数组中的位置
    for(int i = 0; i &lt; 5; i++)&#123;
        if(str == Entity[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateRelationship(string str) &#123;
// 返回str在Relationship数组中的位置
    for(int i = 0; i &lt; 4; i++)&#123;
        if(str == Relationship[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

void InitALGraph(ALGraph&amp; G) &#123;
// 初始化邻接表
    G.vexnum = G.arcnum = 0;
&#125;

void CreateAdjList(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序读取实体存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string info, entity;
    while(ifs &gt;&gt; info &gt;&gt; entity)&#123;
        auto &amp;node = G.vertices[G.vexnum];
        node.info = info;
        node.entity = LocateEntity(entity);
        node.firstarc = nullptr;
        G.vexnum++;
    &#125;
&#125;

void AddArc(ALGraph&amp; G, const string&amp; u, const string&amp; relationship, const string&amp; v)&#123;
    int locU = LocateVex(G, u), locV = LocateVex(G, v);
    int reLoc = LocateRelationship(relationship);
    ArcNode *arc = new ArcNode;
    arc -&gt; adjvex = locV;
    arc -&gt; relationship = reLoc;
    arc -&gt; nextarc = G.vertices[locU].firstarc;
    G.vertices[locU].firstarc = arc;
    G.arcnum++;
&#125;

void CreateUDG(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序三元组存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string u, relationship, v;
    while(ifs &gt;&gt; u &gt;&gt; relationship &gt;&gt; v)&#123;
        AddArc(G, u, relationship, v);
        AddArc(G, v, relationship, u);
    &#125;
&#125;
</code></pre>
<h2 id="第22关：基于路径推理的知识图谱多跳问答"><a href="#第22关：基于路径推理的知识图谱多跳问答" class="headerlink" title="第22关：基于路径推理的知识图谱多跳问答"></a>第22关：基于路径推理的知识图谱多跳问答</h2><h3 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MVNum 10000
using namespace std;

string Relationship[] = &#123;&quot;有功效&quot;,&quot;有食谱&quot;,&quot;有推荐食材&quot;,&quot;有证机概要&quot;&#125;;
typedef struct ArcNode &#123;
    int adjvex;                     // 该边所指向顶点的位置
    int relationship;               // 表示边的类型，即关系的类型，对应为数组下标 
    struct ArcNode* nextarc;        // 下一条边
&#125; ArcNode;                          // 边结点

string Entity[]= &#123;&quot;食材&quot;,&quot;疾病&quot;,&quot;功效&quot;,&quot;食谱&quot;,&quot;证机概要&quot;&#125;;
typedef struct VNode &#123;
    int entity;                     // 表示顶点的类型，即实体的类型，对应为数组下标
    string info;                    // 表示顶点的内容，即实体的内容
    ArcNode* firstarc;              // 指向第一条依附该顶点的边的指针
&#125; VNode, AdjList[MVNum];

typedef struct &#123;
    AdjList vertices;               // 邻接表
    int vexnum, arcnum;             // 图的当前顶点数和边数
&#125; ALGraph;

int LocateVex(ALGraph&amp; G, string str) &#123;
// 返回str在AdjList中的位置
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        if(G.vertices[i].info == str)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateEntity(string str) &#123;
// 返回str在Entity数组中的位置
    for(int i = 0; i &lt; 5; i++)&#123;
        if(str == Entity[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateRelationship(string str) &#123;
// 返回str在Relationship数组中的位置
    for(int i = 0; i &lt; 4; i++)&#123;
        if(str == Relationship[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

void InitALGraph(ALGraph&amp; G) &#123;
// 初始化邻接表
    G.vexnum = G.arcnum = 0;
&#125;

void CreateAdjList(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序读取实体存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string info, entity;
    while(ifs &gt;&gt; info &gt;&gt; entity)&#123;
        auto &amp;node = G.vertices[G.vexnum];
        node.info = info;
        node.entity = LocateEntity(entity);
        node.firstarc = nullptr;
        G.vexnum++;
    &#125;
&#125;

void AddArc(ALGraph&amp; G, const string&amp; u, const string&amp; relationship, const string&amp; v)&#123;
    int locU = LocateVex(G, u), locV = LocateVex(G, v);
    int reLoc = LocateRelationship(relationship);
    ArcNode *arc = new ArcNode;
    arc -&gt; adjvex = locV;
    arc -&gt; relationship = reLoc;
    arc -&gt; nextarc = G.vertices[locU].firstarc;
    G.vertices[locU].firstarc = arc;
    G.arcnum++;
&#125;

void CreateUDG(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序三元组存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string u, relationship, v;
    while(ifs &gt;&gt; u &gt;&gt; relationship &gt;&gt; v)&#123;
        AddArc(G, u, relationship, v);
        AddArc(G, v, relationship, u);
    &#125;
&#125;

void DFS(ALGraph&amp; G, int i, bool visited[], string path, int depth) &#123;
// 深度优先搜索多跳问答路径，i为输入的证机概要在AdjList中的下标，path为问答路径
// 函数可增加额外的参数
    visited[i] = true;
    bool isTail = 1;
    if(depth &lt;= 3)&#123;
        for(auto parc = G.vertices[i].firstarc; parc; parc = parc -&gt; nextarc)&#123;
            if(parc -&gt; relationship == 4 - depth)&#123;
                isTail = 0;
                DFS(G, parc -&gt; adjvex, visited, path + &quot;-&gt;&quot; + G.vertices[parc -&gt; adjvex].info, depth + 1);
            &#125;
        &#125;
    &#125;
    if(depth == 4 || isTail)&#123;
        cout &lt;&lt; path &lt;&lt; endl;
        visited[i] = 0;
        return;
    &#125;
&#125;

void QuestionAnswering(ALGraph&amp; G, string symptom) &#123;
// 调用DFS函数，遍历图G，输出问答序列，symptom为证机概要
    bool *visited = new bool[MVNum];
    memset(visited, 0, MVNum);
    DFS(G, LocateVex(G, symptom), visited, symptom, 1);
    delete[] visited;
&#125;
</code></pre>
<h2 id="第23关：基于编辑距离的食材功效矩阵构建"><a href="#第23关：基于编辑距离的食材功效矩阵构建" class="headerlink" title="第23关：基于编辑距离的食材功效矩阵构建"></a>第23关：基于编辑距离的食材功效矩阵构建</h2><h3 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MVNum 10000
using namespace std;
#define INF 998244353

string Relationship[] = &#123;&quot;有功效&quot;,&quot;有食谱&quot;,&quot;有推荐食材&quot;,&quot;有证机概要&quot;&#125;;
typedef struct ArcNode &#123;
    int adjvex;                     // 该边所指向顶点的位置
    int relationship;               // 表示边的类型，即关系的类型，对应为数组下标 
    struct ArcNode* nextarc;        // 下一条边
&#125; ArcNode;                          // 边结点

string Entity[]= &#123;&quot;食材&quot;,&quot;疾病&quot;,&quot;功效&quot;,&quot;食谱&quot;,&quot;证机概要&quot;&#125;;
typedef struct VNode &#123;
    int entity;                     // 表示顶点的类型，即实体的类型，对应为数组下标
    string info;                    // 表示顶点的内容，即实体的内容
    ArcNode* firstarc;              // 指向第一条依附该顶点的边的指针
&#125; VNode, AdjList[MVNum];

typedef struct &#123;
    AdjList vertices;               // 邻接表
    int vexnum, arcnum;             // 图的当前顶点数和边数
&#125; ALGraph;

typedef struct &#123;
    int vexs[100];                  // 顶点表
    double arcs[100][100];          // 邻接矩阵
    int vexnum, arcnum;             // 图的当前顶点数和边数
&#125; AMGraph;

int LocateVex(ALGraph&amp; G, string str) &#123;
// 返回str在AdjList中的位置
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        if(G.vertices[i].info == str)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateEntity(string str) &#123;
// 返回str在Entity数组中的位置
    for(int i = 0; i &lt; 5; i++)&#123;
        if(str == Entity[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateRelationship(string str) &#123;
// 返回str在Relationship数组中的位置
    for(int i = 0; i &lt; 4; i++)&#123;
        if(str == Relationship[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

void InitALGraph(ALGraph&amp; G) &#123;
// 初始化邻接表
    G.vexnum = G.arcnum = 0;
&#125;

void CreateAdjList(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序读取实体存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string info, entity;
    while(ifs &gt;&gt; info &gt;&gt; entity)&#123;
        auto &amp;node = G.vertices[G.vexnum];
        node.info = info;
        node.entity = LocateEntity(entity);
        node.firstarc = nullptr;
        G.vexnum++;
    &#125;
&#125;

void AddArc(ALGraph&amp; G, const string&amp; u, const string&amp; relationship, const string&amp; v)&#123;
    int locU = LocateVex(G, u), locV = LocateVex(G, v);
    int reLoc = LocateRelationship(relationship);
    ArcNode *arc = new ArcNode;
    arc -&gt; adjvex = locV;
    arc -&gt; relationship = reLoc;
    arc -&gt; nextarc = G.vertices[locU].firstarc;
    G.vertices[locU].firstarc = arc;
    G.arcnum++;
&#125;

void CreateUDG(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序三元组存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string u, relationship, v;
    while(ifs &gt;&gt; u &gt;&gt; relationship &gt;&gt; v)&#123;
        AddArc(G, u, relationship, v);
        AddArc(G, v, relationship, u);
    &#125;
&#125;

int LevenshteinDistance(string s1, string s2) &#123;
// 定义一个函数，计算两个字符串的莱文斯坦距离
    int m = s1.length();            
    int n = s2.length();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
    for (int i = 0; i &lt;= m; i++) &#123;
        dp[i][0] = i;
    &#125;
    for (int j = 0; j &lt;= n; j++) &#123;
        dp[0][j] = j;
    &#125;
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (s1[i - 1] == s2[j - 1]) &#123;
                dp[i][j] = dp[i - 1][j - 1];
            &#125; else &#123;
                dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
            &#125;
        &#125;
    &#125;
    return dp[m][n];
&#125;

double TextSimilarity(string s1, string s2) &#123;
// 定义一个函数，计算两个字符串的文本相似度，文本相似度 = 1 - 莱文斯坦距离 / 最大字符串长度
    int dist = LevenshteinDistance(s1, s2);
    int max_len = max(s1.length(), s2.length());
    double s = 1.0 - (double)dist / max_len;
    return s;
&#125;

void GetInfo(ALGraph&amp; G, int i, string&amp; s)&#123;
    for(ArcNode *arc = G.vertices[i].firstarc; arc; arc = arc -&gt; nextarc)&#123;
        // if(arc -&gt; relationship == 0)&#123;
        if(G.vertices[arc -&gt; adjvex].entity == 2)&#123;
            s += G.vertices[arc -&gt; adjvex].info;
            s += &quot;#&quot;;
        &#125;
    &#125;
    if(s.size()) s.pop_back();
&#125;

void InitAMGraph(AMGraph&amp; GM)&#123;
    GM.vexnum = 0;
    GM.arcnum = 0;
&#125;

void CreateAMG(AMGraph&amp; GM, ALGraph&amp; G) &#123;
// 调用编辑距离算法计算相似度，构建食材之间的邻接矩阵
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        if(G.vertices[i].entity == 0)&#123;
            GM.vexs[GM.vexnum++] = i;
            if(GM.vexnum == 100) break;
        &#125;
    &#125;

    for(int i = 0; i &lt; GM.vexnum; i++)&#123;
        for(int j = 0; j &lt; GM.vexnum; j++)&#123;
            string s1, s2;
            GetInfo(G, GM.vexs[i], s1);
            GetInfo(G, GM.vexs[j], s2);
            GM.arcs[i][j] = 1 - TextSimilarity(s1, s2);
            GM.arcnum++;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="第24关：基于Dijkstra算法的食材推荐"><a href="#第24关：基于Dijkstra算法的食材推荐" class="headerlink" title="第24关：基于Dijkstra算法的食材推荐"></a>第24关：基于Dijkstra算法的食材推荐</h2><h3 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MVNum 10000
using namespace std;
#define INF 998244353

string Relationship[] = &#123;&quot;有功效&quot;,&quot;有食谱&quot;,&quot;有推荐食材&quot;,&quot;有证机概要&quot;&#125;;
typedef struct ArcNode &#123;
    int adjvex;                     // 该边所指向顶点的位置
    int relationship;               // 表示边的类型，即关系的类型，对应为数组下标 
    struct ArcNode* nextarc;        // 下一条边
&#125; ArcNode;                          // 边结点

string Entity[]= &#123;&quot;食材&quot;,&quot;疾病&quot;,&quot;功效&quot;,&quot;食谱&quot;,&quot;证机概要&quot;&#125;;
typedef struct VNode &#123;
    int entity;                     // 表示顶点的类型，即实体的类型，对应为数组下标
    string info;                    // 表示顶点的内容，即实体的内容
    ArcNode* firstarc;              // 指向第一条依附该顶点的边的指针
&#125; VNode, AdjList[MVNum];

typedef struct &#123;
    AdjList vertices;               // 邻接表
    int vexnum, arcnum;             // 图的当前顶点数和边数
&#125; ALGraph;

typedef struct &#123;
    int vexs[100];                  // 顶点表
    double arcs[100][100];          // 邻接矩阵
    int vexnum, arcnum;             // 图的当前顶点数和边数
&#125; AMGraph;

int LocateVex(ALGraph&amp; G, string str) &#123;
// 返回str在AdjList中的位置
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        if(G.vertices[i].info == str)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateEntity(string str) &#123;
// 返回str在Entity数组中的位置
    for(int i = 0; i &lt; 5; i++)&#123;
        if(str == Entity[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateRelationship(string str) &#123;
// 返回str在Relationship数组中的位置
    for(int i = 0; i &lt; 4; i++)&#123;
        if(str == Relationship[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

void InitALGraph(ALGraph&amp; G) &#123;
// 初始化邻接表
    G.vexnum = G.arcnum = 0;
&#125;

void CreateAdjList(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序读取实体存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string info, entity;
    while(ifs &gt;&gt; info &gt;&gt; entity)&#123;
        auto &amp;node = G.vertices[G.vexnum];
        node.info = info;
        node.entity = LocateEntity(entity);
        node.firstarc = nullptr;
        G.vexnum++;
    &#125;
&#125;

void AddArc(ALGraph&amp; G, const string&amp; u, const string&amp; relationship, const string&amp; v)&#123;
    int locU = LocateVex(G, u), locV = LocateVex(G, v);
    int reLoc = LocateRelationship(relationship);
    ArcNode *arc = new ArcNode;
    arc -&gt; adjvex = locV;
    arc -&gt; relationship = reLoc;
    arc -&gt; nextarc = G.vertices[locU].firstarc;
    G.vertices[locU].firstarc = arc;
    G.arcnum++;
&#125;

void CreateUDG(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序三元组存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string u, relationship, v;
    while(ifs &gt;&gt; u &gt;&gt; relationship &gt;&gt; v)&#123;
        AddArc(G, u, relationship, v);
        AddArc(G, v, relationship, u);
    &#125;
&#125;

int LevenshteinDistance(string s1, string s2) &#123;
// 定义一个函数，计算两个字符串的莱文斯坦距离
    int m = s1.length();            
    int n = s2.length();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
    for (int i = 0; i &lt;= m; i++) &#123;
        dp[i][0] = i;
    &#125;
    for (int j = 0; j &lt;= n; j++) &#123;
        dp[0][j] = j;
    &#125;
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (s1[i - 1] == s2[j - 1]) &#123;
                dp[i][j] = dp[i - 1][j - 1];
            &#125; else &#123;
                dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
            &#125;
        &#125;
    &#125;
    return dp[m][n];
&#125;

double TextSimilarity(string s1, string s2) &#123;
// 定义一个函数，计算两个字符串的文本相似度，文本相似度 = 1 - 莱文斯坦距离 / 最大字符串长度
    int dist = LevenshteinDistance(s1, s2);
    int max_len = max(s1.length(), s2.length());
    double s = 1.0 - (double)dist / max_len;
    return s;
&#125;

void GetInfo(ALGraph&amp; G, int i, string&amp; s)&#123;
    for(ArcNode *arc = G.vertices[i].firstarc; arc; arc = arc -&gt; nextarc)&#123;
        // if(arc -&gt; relationship == 0)&#123;
        if(G.vertices[arc -&gt; adjvex].entity == 2)&#123;
            s += G.vertices[arc -&gt; adjvex].info;
            s += &quot;#&quot;;
        &#125;
    &#125;
    if(s.size()) s.pop_back();
&#125;

void InitAMGraph(AMGraph&amp; GM)&#123;
    GM.vexnum = 0;
    GM.arcnum = 0;
&#125;

void CreateAMG(AMGraph&amp; GM, ALGraph&amp; G) &#123;
// 调用编辑距离算法计算相似度，构建食材之间的邻接矩阵
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        if(G.vertices[i].entity == 0)&#123;
            GM.vexs[GM.vexnum++] = i;
            if(GM.vexnum == 100) break;
        &#125;
    &#125;

    for(int i = 0; i &lt; GM.vexnum; i++)&#123;
        for(int j = 0; j &lt; GM.vexnum; j++)&#123;
            string s1, s2;
            GetInfo(G, GM.vexs[i], s1);
            GetInfo(G, GM.vexs[j], s2);
            GM.arcs[i][j] = 1 - TextSimilarity(s1, s2);
            GM.arcnum++;
        &#125;
    &#125;
&#125;

void ShortestPathDIJ(AMGraph&amp; G, bool S[], double D[], int v0) &#123;
// 使用迪杰斯特拉算法求最短路径，S表示是否已被确定最短路径长度，D表示最短路径长度，v0表示顶点下标
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        D[i] = INF, S[0] = 0;
    &#125;
    D[v0] = 0;
    for(int i = 0; i &lt; G.vexnum - 1; i++)&#123;
        int t = -1;
        for(int j = 0; j &lt; G.vexnum; j++)&#123;
            if(!S[j] &amp;&amp; (t == -1 || D[j] &lt; D[t]))&#123;
                t = j;
            &#125;
        &#125;
        for(int j = 0; j &lt; G.vexnum; j++)&#123;
            D[j] = min(D[j], D[t] + G.arcs[t][j]);
        &#125;
        S[t] = 1;
    &#125;
&#125;
</code></pre>
<h2 id="第25关：基于Floyd算法的食材推荐"><a href="#第25关：基于Floyd算法的食材推荐" class="headerlink" title="第25关：基于Floyd算法的食材推荐"></a>第25关：基于Floyd算法的食材推荐</h2><h3 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
#define MVNum 10000
using namespace std;

string Relationship[] = &#123;&quot;有功效&quot;,&quot;有食谱&quot;,&quot;有推荐食材&quot;,&quot;有证机概要&quot;&#125;;
typedef struct ArcNode &#123;
    int adjvex;                     // 该边所指向顶点的位置
    int relationship;               // 表示边的类型，即关系的类型，对应为数组下标 
    struct ArcNode* nextarc;        // 下一条边
&#125; ArcNode;                          // 边结点

string Entity[]= &#123;&quot;食材&quot;,&quot;疾病&quot;,&quot;功效&quot;,&quot;食谱&quot;,&quot;证机概要&quot;&#125;;
typedef struct VNode &#123;
    int entity;                     // 表示顶点的类型，即实体的类型，对应为数组下标
    string info;                    // 表示顶点的内容，即实体的内容
    ArcNode* firstarc;              // 指向第一条依附该顶点的边的指针
&#125; VNode, AdjList[MVNum];

typedef struct &#123;
    AdjList vertices;               // 邻接表
    int vexnum, arcnum;             // 图的当前顶点数和边数
&#125; ALGraph;

typedef struct &#123;
    int vexs[100];                  // 顶点表
    double arcs[100][100];          // 邻接矩阵
    int vexnum, arcnum;             // 图的当前顶点数和边数
&#125; AMGraph;

int LocateVex(ALGraph&amp; G, string str) &#123;
// 返回str在AdjList中的位置
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        if(G.vertices[i].info == str)&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateEntity(string str) &#123;
// 返回str在Entity数组中的位置
    for(int i = 0; i &lt; 5; i++)&#123;
        if(str == Entity[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

int LocateRelationship(string str) &#123;
// 返回str在Relationship数组中的位置
    for(int i = 0; i &lt; 4; i++)&#123;
        if(str == Relationship[i])&#123;
            return i;
        &#125;
    &#125;
    return -1;
&#125;

void InitALGraph(ALGraph&amp; G) &#123;
// 初始化邻接表
    G.vexnum = G.arcnum = 0;
&#125;

void CreateAdjList(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序读取实体存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string info, entity;
    while(ifs &gt;&gt; info &gt;&gt; entity)&#123;
        auto &amp;node = G.vertices[G.vexnum];
        node.info = info;
        node.entity = LocateEntity(entity);
        node.firstarc = nullptr;
        G.vexnum++;
    &#125;
&#125;

void AddArc(ALGraph&amp; G, const string&amp; u, const string&amp; relationship, const string&amp; v)&#123;
    int locU = LocateVex(G, u), locV = LocateVex(G, v);
    int reLoc = LocateRelationship(relationship);
    ArcNode *arc = new ArcNode;
    arc -&gt; adjvex = locV;
    arc -&gt; relationship = reLoc;
    arc -&gt; nextarc = G.vertices[locU].firstarc;
    G.vertices[locU].firstarc = arc;
    G.arcnum++;
&#125;

void CreateUDG(ALGraph&amp; G, string filename) &#123;
// 从filename中按顺序三元组存入邻接表
    ifstream ifs(filename);
    if(!ifs.is_open()) return;

    string u, relationship, v;
    while(ifs &gt;&gt; u &gt;&gt; relationship &gt;&gt; v)&#123;
        AddArc(G, u, relationship, v);
        AddArc(G, v, relationship, u);
    &#125;
&#125;

int LevenshteinDistance(string s1, string s2) &#123;
// 定义一个函数，计算两个字符串的莱文斯坦距离
    int m = s1.length();            
    int n = s2.length();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
    for (int i = 0; i &lt;= m; i++) &#123;
        dp[i][0] = i;
    &#125;
    for (int j = 0; j &lt;= n; j++) &#123;
        dp[0][j] = j;
    &#125;
    for (int i = 1; i &lt;= m; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (s1[i - 1] == s2[j - 1]) &#123;
                dp[i][j] = dp[i - 1][j - 1];
            &#125; else &#123;
                dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
            &#125;
        &#125;
    &#125;
    return dp[m][n];
&#125;

double TextSimilarity(string s1, string s2) &#123;
// 定义一个函数，计算两个字符串的文本相似度，文本相似度 = 1 - 莱文斯坦距离 / 最大字符串长度
    int dist = LevenshteinDistance(s1, s2);
    int max_len = max(s1.length(), s2.length());
    double s = 1.0 - (double)dist / max_len;
    return s;
&#125;

void GetInfo(ALGraph&amp; G, int i, string&amp; s)&#123;
    for(ArcNode *arc = G.vertices[i].firstarc; arc; arc = arc -&gt; nextarc)&#123;
        // if(arc -&gt; relationship == 0)&#123;
        if(G.vertices[arc -&gt; adjvex].entity == 2)&#123;
            s += G.vertices[arc -&gt; adjvex].info;
            s += &quot;#&quot;;
        &#125;
    &#125;
    if(s.size()) s.pop_back();
&#125;

void InitAMGraph(AMGraph&amp; GM)&#123;
    GM.vexnum = 0;
    GM.arcnum = 0;
&#125;

void CreateAMG(AMGraph&amp; GM, ALGraph&amp; G) &#123;
// 调用编辑距离算法计算相似度，构建食材之间的邻接矩阵
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        if(G.vertices[i].entity == 0)&#123;
            GM.vexs[GM.vexnum++] = i;
            if(GM.vexnum == 100) break;
        &#125;
    &#125;

    for(int i = 0; i &lt; GM.vexnum; i++)&#123;
        for(int j = 0; j &lt; GM.vexnum; j++)&#123;
            string s1, s2;
            GetInfo(G, GM.vexs[i], s1);
            GetInfo(G, GM.vexs[j], s2);
            GM.arcs[i][j] = 1 - TextSimilarity(s1, s2);
            GM.arcnum++;
        &#125;
    &#125;
&#125;


void ShortestPathFloyd(AMGraph&amp; G, double D[][100]) &#123;
// 使用弗洛伊德算法求最短路径，D表示最短路径长度
    for(int i = 0; i &lt; G.vexnum; i++)&#123;
        for(int j = 0; j &lt; G.vexnum; j++)&#123;
            D[i][j] = G.arcs[i][j];
        &#125;
    &#125;
    for(int k = 0; k &lt; G.vexnum; k++)&#123;
        for(int i = 0; i &lt; G.vexnum; i++)&#123;
            for(int j = 0; j &lt; G.vexnum; j++)&#123;
                D[i][j] = min(D[i][j], D[i][k] + D[k][j]);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Yhs_JokerのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Yhs_Joker
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        
<script
    src="https://giscus.app/client.js"
    data-repo="yhsjoker/yhsjoker.github.io"
    data-repo-id="R_kgDOIchRxw"
    data-category="Announcements"
    data-category-id="DIC_kwDOIchRx84CZAz1"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
